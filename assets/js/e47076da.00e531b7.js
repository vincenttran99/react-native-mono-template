"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[575],{6748:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>c,frontMatter:()=>r,metadata:()=>t,toc:()=>m});const t=JSON.parse('{"id":"performance/image-optimization","title":"Image Optimization","description":"Understanding Image Performance Challenges","source":"@site/docs/performance/image-optimization.md","sourceDirName":"performance","slug":"/performance/image-optimization","permalink":"/react-native-mono-template/docs/performance/image-optimization","draft":false,"unlisted":false,"editUrl":"https://github.com/vincenttran99/react-native-mono-template/edit/main/docs/docs/performance/image-optimization.md","tags":[],"version":"current","sidebarPosition":6,"frontMatter":{"sidebar_position":6},"sidebar":"docs","previous":{"title":"Animation Optimization","permalink":"/react-native-mono-template/docs/performance/animation-optimization"},"next":{"title":"Data and State Management Optimization","permalink":"/react-native-mono-template/docs/performance/data-state-optimization"}}');var a=i(4848),s=i(8453);const r={sidebar_position:6},o="Image Optimization",l={},m=[{value:"Understanding Image Performance Challenges",id:"understanding-image-performance-challenges",level:2},{value:"Key Optimization Techniques",id:"key-optimization-techniques",level:2},{value:"1. Using FastImage Instead of Standard Image Component",id:"1-using-fastimage-instead-of-standard-image-component",level:3},{value:"2. Implementing Native Image Components",id:"2-implementing-native-image-components",level:3},{value:"3. Progressive Image Loading",id:"3-progressive-image-loading",level:3},{value:"4. Image Resizing and Compression",id:"4-image-resizing-and-compression",level:3},{value:"5. Static Content Pre-compilation",id:"5-static-content-pre-compilation",level:3},{value:"6. Bitmap Caching for Static Images",id:"6-bitmap-caching-for-static-images",level:3},{value:"7. Lazy Loading Images",id:"7-lazy-loading-images",level:3},{value:"Measuring Image Performance",id:"measuring-image-performance",level:2},{value:"Best Practices Summary",id:"best-practices-summary",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"image-optimization",children:"Image Optimization"})}),"\n",(0,a.jsx)(n.h2,{id:"understanding-image-performance-challenges",children:"Understanding Image Performance Challenges"}),"\n",(0,a.jsx)(n.p,{children:"Images in React Native can cause performance issues due to:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Large file sizes"}),": High-resolution images consume bandwidth and storage"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Memory usage"}),": Unoptimized images can cause memory spikes and crashes"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Decoding overhead"}),": Image decoding happens on the main thread by default"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Rendering cost"}),": Complex image operations can slow down UI rendering"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Cache management"}),": Inefficient caching leads to redundant downloads and processing"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"key-optimization-techniques",children:"Key Optimization Techniques"}),"\n",(0,a.jsx)(n.h3,{id:"1-using-fastimage-instead-of-standard-image-component",children:"1. Using FastImage Instead of Standard Image Component"}),"\n",(0,a.jsxs)(n.p,{children:["The standard React Native ",(0,a.jsx)(n.code,{children:"Image"})," component has several limitations. ",(0,a.jsx)(n.code,{children:"FastImage"})," provides significant performance improvements:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-jsx",children:'import FastImage from "react-native-fast-image";\n\nconst OptimizedAvatar = ({ uri, size }) => (\n  <FastImage\n    style={{ width: size, height: size, borderRadius: size / 2 }}\n    source={{\n      uri,\n      priority: FastImage.priority.high,\n      cache: FastImage.cacheControl.immutable,\n    }}\n    resizeMode={FastImage.resizeMode.cover}\n  />\n);\n'})}),"\n",(0,a.jsx)(n.p,{children:"Key benefits of FastImage:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Better caching"}),": Uses OkHttp's disk caching on Android and SDWebImage on iOS"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Priority control"}),": Allows setting loading priorities for critical images"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Cache control"}),": Provides fine-grained cache control options"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Preloading"}),": Supports preloading images before they're needed"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Performance"}),": Significantly reduces image loading jank and stuttering"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"Advanced usage with preloading:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-jsx",children:'// Preload important images when app starts\nconst preloadImages = () => {\n  const uris = [\n    "https://example.com/header-image.jpg",\n    "https://example.com/profile-image.jpg",\n    // More critical images\n  ];\n\n  FastImage.preload(uris.map((uri) => ({ uri })));\n};\n\n// Preload images for the next screen\nconst prepareNextScreen = (nextScreenImages) => {\n  FastImage.preload(\n    nextScreenImages.map((image) => ({\n      uri: image.uri,\n      priority: FastImage.priority.normal,\n    }))\n  );\n};\n'})}),"\n",(0,a.jsx)(n.h3,{id:"2-implementing-native-image-components",children:"2. Implementing Native Image Components"}),"\n",(0,a.jsx)(n.p,{children:"For high-performance image-intensive features, consider implementing native image components:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-jsx",children:'import { requireNativeComponent, Platform } from "react-native";\n\n// Custom native component optimized for image grids\nconst NativeImageGrid = Platform.select({\n  ios: () => requireNativeComponent("RCTOptimizedImageGrid"),\n  android: () => requireNativeComponent("OptimizedImageGridView"),\n  default: () => View,\n})();\n\nconst HighPerformanceImageGrid = ({ images, onImagePress }) => (\n  <NativeImageGrid\n    images={images.map((img) => img.url)}\n    onImagePress={onImagePress}\n    style={styles.imageGrid}\n    placeholderColor="#E1E2E3"\n    loadingIndicatorColor="#0066CC"\n    imageFitMode="cover"\n  />\n);\n'})}),"\n",(0,a.jsx)(n.p,{children:"Benefits of native image components:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Optimized rendering"}),": Direct use of native image libraries (Glide/Fresco on Android, SDWebImage on iOS)"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Memory management"}),": Better memory handling for large image collections"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Recycling"}),": Efficient view recycling for image lists and grids"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Threading"}),": Image processing on background threads by default"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Hardware acceleration"}),": Better utilization of GPU for image rendering"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"3-progressive-image-loading",children:"3. Progressive Image Loading"}),"\n",(0,a.jsx)(n.p,{children:"Implement progressive image loading for a better user experience:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-jsx",children:'const ProgressiveImage = ({ thumbnailSource, source, style, ...props }) => {\n  const [isLoaded, setIsLoaded] = useState(false);\n  const thumbnailAnimated = useRef(new Animated.Value(0)).current;\n  const imageAnimated = useRef(new Animated.Value(0)).current;\n\n  const handleThumbnailLoad = () => {\n    Animated.timing(thumbnailAnimated, {\n      toValue: 1,\n      duration: 200,\n      useNativeDriver: true,\n    }).start();\n  };\n\n  const handleImageLoad = () => {\n    setIsLoaded(true);\n    Animated.timing(imageAnimated, {\n      toValue: 1,\n      duration: 300,\n      useNativeDriver: true,\n    }).start();\n  };\n\n  return (\n    <View style={[styles.container, style]}>\n      <Animated.Image\n        {...props}\n        source={thumbnailSource}\n        style={[style, { opacity: thumbnailAnimated }]}\n        onLoad={handleThumbnailLoad}\n        blurRadius={2}\n      />\n      <Animated.Image\n        {...props}\n        source={source}\n        style={[styles.imageOverlay, { opacity: imageAnimated }, style]}\n        onLoad={handleImageLoad}\n      />\n      {!isLoaded && (\n        <View style={styles.loadingContainer}>\n          <ActivityIndicator size="small" color="#0066CC" />\n        </View>\n      )}\n    </View>\n  );\n};\n\n// Usage\n<ProgressiveImage\n  thumbnailSource={{ uri: `${image.uri}?width=50` }}\n  source={{ uri: image.uri }}\n  style={styles.image}\n/>;\n'})}),"\n",(0,a.jsx)(n.h3,{id:"4-image-resizing-and-compression",children:"4. Image Resizing and Compression"}),"\n",(0,a.jsx)(n.p,{children:"Resize and compress images before displaying them:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-jsx",children:'import ImageResizer from "react-native-image-resizer";\n\nconst optimizeImage = async (\n  imageUri,\n  maxWidth = 1200,\n  maxHeight = 1200,\n  quality = 80\n) => {\n  try {\n    const result = await ImageResizer.createResizedImage(\n      imageUri,\n      maxWidth,\n      maxHeight,\n      "JPEG",\n      quality,\n      0,\n      undefined,\n      false,\n      { mode: "contain", onlyScaleDown: true }\n    );\n\n    return result.uri;\n  } catch (error) {\n    console.error("Image optimization failed:", error);\n    return imageUri; // Return original if optimization fails\n  }\n};\n\n// Usage in component\nconst OptimizedImageUploader = ({ originalUri }) => {\n  const [optimizedUri, setOptimizedUri] = useState(null);\n\n  useEffect(() => {\n    const prepareImage = async () => {\n      const optimized = await optimizeImage(originalUri);\n      setOptimizedUri(optimized);\n    };\n\n    prepareImage();\n  }, [originalUri]);\n\n  return (\n    <View style={styles.container}>\n      {optimizedUri ? (\n        <FastImage source={{ uri: optimizedUri }} style={styles.image} />\n      ) : (\n        <ActivityIndicator size="large" color="#0066CC" />\n      )}\n    </View>\n  );\n};\n'})}),"\n",(0,a.jsx)(n.h3,{id:"5-static-content-pre-compilation",children:"5. Static Content Pre-compilation"}),"\n",(0,a.jsx)(n.p,{children:"Pre-build templates for static content including images to improve performance:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-jsx",children:'// Pre-build templates for static content\nconst TEMPLATES = {\n  standard: ({ title, subtitle, image }) => (\n    <View style={styles.standardTemplate}>\n      <Text style={styles.title}>{title}</Text>\n      <Text style={styles.subtitle}>{subtitle}</Text>\n      <FastImage source={{ uri: image }} style={styles.image} />\n    </View>\n  ),\n  compact: ({ title, image }) => (\n    <View style={styles.compactTemplate}>\n      <FastImage source={{ uri: image }} style={styles.smallImage} />\n      <Text style={styles.smallTitle}>{title}</Text>\n    </View>\n  ),\n  hero: ({ title, image, description }) => (\n    <View style={styles.heroTemplate}>\n      <FastImage\n        source={{ uri: image }}\n        style={styles.heroImage}\n        resizeMode={FastImage.resizeMode.cover}\n      />\n      <LinearGradient\n        colors={["transparent", "rgba(0,0,0,0.8)"]}\n        style={styles.gradient}\n      >\n        <Text style={styles.heroTitle}>{title}</Text>\n        <Text style={styles.heroDescription}>{description}</Text>\n      </LinearGradient>\n    </View>\n  ),\n};\n\n// Usage\nconst TemplatedItem = ({ item }) => {\n  const Template = TEMPLATES[item.templateType] || TEMPLATES.standard;\n  return <Template {...item.data} />;\n};\n\n// Example implementation\nconst ImageGallery = ({ items }) => {\n  return (\n    <FlatList\n      data={items}\n      keyExtractor={(item) => item.id}\n      renderItem={({ item }) => <TemplatedItem item={item} />}\n      getItemLayout={(data, index) => ({\n        length: item.templateType === "hero" ? 300 : 200,\n        offset: item.templateType === "hero" ? 300 * index : 200 * index,\n        index,\n      })}\n      removeClippedSubviews={true}\n    />\n  );\n};\n\n// Styles for templates\nconst styles = StyleSheet.create({\n  standardTemplate: {\n    padding: 16,\n    backgroundColor: "white",\n    borderRadius: 8,\n    marginBottom: 16,\n    shadowColor: "#000",\n    shadowOpacity: 0.1,\n    shadowRadius: 4,\n    shadowOffset: { width: 0, height: 2 },\n    elevation: 2,\n  },\n  title: {\n    fontSize: 18,\n    fontWeight: "bold",\n    marginBottom: 8,\n  },\n  subtitle: {\n    fontSize: 14,\n    color: "#666",\n    marginBottom: 12,\n  },\n  image: {\n    width: "100%",\n    height: 200,\n    borderRadius: 4,\n  },\n  compactTemplate: {\n    flexDirection: "row",\n    alignItems: "center",\n    padding: 12,\n    backgroundColor: "white",\n    borderRadius: 8,\n    marginBottom: 12,\n  },\n  smallImage: {\n    width: 80,\n    height: 80,\n    borderRadius: 4,\n    marginRight: 12,\n  },\n  smallTitle: {\n    fontSize: 16,\n    fontWeight: "600",\n    flex: 1,\n  },\n  heroTemplate: {\n    height: 300,\n    borderRadius: 8,\n    overflow: "hidden",\n    marginBottom: 16,\n  },\n  heroImage: {\n    width: "100%",\n    height: "100%",\n  },\n  gradient: {\n    position: "absolute",\n    bottom: 0,\n    left: 0,\n    right: 0,\n    height: 120,\n    padding: 16,\n    justifyContent: "flex-end",\n  },\n  heroTitle: {\n    color: "white",\n    fontSize: 24,\n    fontWeight: "bold",\n    marginBottom: 8,\n  },\n  heroDescription: {\n    color: "rgba(255,255,255,0.9)",\n    fontSize: 14,\n  },\n});\n'})}),"\n",(0,a.jsx)(n.p,{children:"Benefits of static content pre-compilation:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Reduced render time"}),": Templates are pre-defined and optimized"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Consistent UI"}),": Ensures visual consistency across the app"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Memory efficiency"}),": Reuses the same template structure for multiple items"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Reduced JS bridge traffic"}),": Minimizes prop changes and re-renders"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Optimized image loading"}),": Templates can include optimized image loading strategies"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"6-bitmap-caching-for-static-images",children:"6. Bitmap Caching for Static Images"}),"\n",(0,a.jsx)(n.p,{children:"For static images that rarely change, use bitmap caching:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-jsx",children:"const StaticImageComponent = ({ imageUrl, title }) => (\n  <View\n    style={styles.container}\n    shouldRasterizeIOS={true} // iOS optimization\n    renderToHardwareTextureAndroid={true} // Android optimization\n  >\n    <FastImage\n      source={{ uri: imageUrl }}\n      style={styles.image}\n      resizeMode={FastImage.resizeMode.cover}\n    />\n    <Text style={styles.title}>{title}</Text>\n  </View>\n);\n"})}),"\n",(0,a.jsx)(n.p,{children:"When to use bitmap caching:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Static headers with images"}),"\n",(0,a.jsx)(n.li,{children:"Image-based UI elements that don't change frequently"}),"\n",(0,a.jsx)(n.li,{children:"Complex image compositions with overlays or effects"}),"\n",(0,a.jsx)(n.li,{children:"Images with applied transformations or filters"}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"7-lazy-loading-images",children:"7. Lazy Loading Images"}),"\n",(0,a.jsx)(n.p,{children:"Implement lazy loading for images in long scrolling views:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-jsx",children:"const LazyLoadedImage = ({ item, isVisible }) => {\n  const [loaded, setLoaded] = useState(false);\n\n  useEffect(() => {\n    if (isVisible && !loaded) {\n      // Only start loading when visible\n      setLoaded(true);\n    }\n  }, [isVisible]);\n\n  if (!loaded) {\n    return <View style={[styles.imagePlaceholder, { height: item.height }]} />;\n  }\n\n  return (\n    <FastImage\n      source={{ uri: item.imageUrl }}\n      style={[styles.image, { height: item.height }]}\n      onLoad={() => console.log(`Image ${item.id} loaded`)}\n    />\n  );\n};\n\n// In a list component\nconst ImageList = ({ images }) => {\n  const [visibleIndices, setVisibleIndices] = useState(new Set());\n\n  const handleViewableItemsChanged = useCallback(({ viewableItems }) => {\n    const newVisible = new Set(viewableItems.map((item) => item.index));\n    setVisibleIndices(newVisible);\n  }, []);\n\n  const renderItem = ({ item, index }) => (\n    <LazyLoadedImage item={item} isVisible={visibleIndices.has(index)} />\n  );\n\n  return (\n    <FlashList\n      data={images}\n      renderItem={renderItem}\n      estimatedItemSize={200}\n      onViewableItemsChanged={handleViewableItemsChanged}\n      viewabilityConfig={{\n        itemVisiblePercentThreshold: 20,\n        minimumViewTime: 300,\n      }}\n    />\n  );\n};\n"})}),"\n",(0,a.jsx)(n.h2,{id:"measuring-image-performance",children:"Measuring Image Performance"}),"\n",(0,a.jsx)(n.p,{children:"To identify image performance issues:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Memory Profiling"}),": Monitor memory usage during image-heavy operations"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Network Monitoring"}),": Track image download sizes and times"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Frame Rate Analysis"}),": Measure FPS drops during image loading and scrolling"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Startup Time"}),": Measure impact of preloaded images on app startup time"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"best-practices-summary",children:"Best Practices Summary"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Use FastImage"})," instead of the standard Image component"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Implement native components"})," for image-intensive features"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Apply progressive loading"})," for better user experience"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Resize and compress images"})," before displaying"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Pre-compile static content"})," with optimized templates"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Use bitmap caching"})," for static images"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Implement lazy loading"})," for images in scrolling views"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Choose appropriate image formats"})," for different use cases"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Manage memory"})," in image-heavy screens"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Measure and optimize"})," based on performance metrics"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"By implementing these optimization techniques, you can significantly improve image performance in your React Native application, leading to faster load times, smoother scrolling, and better overall user experience."})]})}function c(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>r,x:()=>o});var t=i(6540);const a={},s=t.createContext(a);function r(e){const n=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);