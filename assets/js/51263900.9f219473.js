"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[949],{5117:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>m,frontMatter:()=>r,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"performance/data-state-optimization","title":"Data and State Management Optimization","description":"Efficient data and state management is a crucial factor in creating high-performance React Native applications. As applications grow, inefficient data handling and state management can lead to performance issues such as unnecessary re-renders, repetitive calculations, and excessive memory usage.","source":"@site/docs/performance/data-state-optimization.md","sourceDirName":"performance","slug":"/performance/data-state-optimization","permalink":"/react-native-mono-template/docs/performance/data-state-optimization","draft":false,"unlisted":false,"editUrl":"https://github.com/vincenttran99/react-native-mono-template/edit/main/docs/docs/performance/data-state-optimization.md","tags":[],"version":"current","sidebarPosition":7,"frontMatter":{"sidebar_position":7},"sidebar":"docs","previous":{"title":"Image Optimization","permalink":"/react-native-mono-template/docs/performance/image-optimization"}}');var a=t(4848),i=t(8453);const r={sidebar_position:7},o="Data and State Management Optimization",l={},c=[{value:"Understanding Data and State Management Challenges",id:"understanding-data-and-state-management-challenges",level:2},{value:"Key Optimization Techniques",id:"key-optimization-techniques",level:2},{value:"1. Creating Custom Hooks for List State Management",id:"1-creating-custom-hooks-for-list-state-management",level:3},{value:"2. Optimizing Data Processing with useMemo",id:"2-optimizing-data-processing-with-usememo",level:3},{value:"3. Optimizing Props Stability with useMemo",id:"3-optimizing-props-stability-with-usememo",level:3},{value:"4. Using Context API Effectively",id:"4-using-context-api-effectively",level:3},{value:"5. Using Selector Pattern",id:"5-using-selector-pattern",level:3},{value:"6. Proxy-based State Management",id:"6-proxy-based-state-management",level:3},{value:"7. Hybrid Native/JS Rendering Strategy",id:"7-hybrid-nativejs-rendering-strategy",level:3},{value:"Advanced Optimization Techniques",id:"advanced-optimization-techniques",level:2},{value:"1. Using Memoization Cache",id:"1-using-memoization-cache",level:3},{value:"2. Using Normalized State Shape",id:"2-using-normalized-state-shape",level:3},{value:"3. Lazy State Initialization",id:"3-lazy-state-initialization",level:3},{value:"Measuring Data and State Management Performance",id:"measuring-data-and-state-management-performance",level:2},{value:"Best Practices Summary",id:"best-practices-summary",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"data-and-state-management-optimization",children:"Data and State Management Optimization"})}),"\n",(0,a.jsx)(n.p,{children:"Efficient data and state management is a crucial factor in creating high-performance React Native applications. As applications grow, inefficient data handling and state management can lead to performance issues such as unnecessary re-renders, repetitive calculations, and excessive memory usage."}),"\n",(0,a.jsx)(n.h2,{id:"understanding-data-and-state-management-challenges",children:"Understanding Data and State Management Challenges"}),"\n",(0,a.jsx)(n.p,{children:"Data and state management in React Native can face performance issues due to:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Unnecessary re-renders"}),": When state changes, components may re-render even when not necessary"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Repetitive calculations"}),": Complex data processing may be performed multiple times unnecessarily"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Prop drilling through many layers"}),": Leading to cascading re-renders and debugging difficulties"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Distributed state management"}),": Increasing complexity and making optimization difficult"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Inefficient data processing"}),": Expensive data transformations can slow down the application"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"key-optimization-techniques",children:"Key Optimization Techniques"}),"\n",(0,a.jsx)(n.h3,{id:"1-creating-custom-hooks-for-list-state-management",children:"1. Creating Custom Hooks for List State Management"}),"\n",(0,a.jsx)(n.p,{children:"Custom hooks help encapsulate data processing and state management logic, separating it from UI:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-jsx",children:'const useOptimizedList = (sourceData) => {\n  const [refreshing, setRefreshing] = useState(false);\n  const [selectedId, setSelectedId] = useState(null);\n\n  // Process data only once when sourceData changes\n  const data = useMemo(() => {\n    console.log("Processing list data...");\n    return sourceData.map((item) => ({\n      ...item,\n      formattedDate: formatDate(item.timestamp),\n      displayName: `${item.firstName} ${item.lastName}`,\n      // Other data transformations\n    }));\n  }, [sourceData]);\n\n  // Memoize handlers to avoid creating new functions on each render\n  const handleRefresh = useCallback(() => {\n    setRefreshing(true);\n    // Refresh data logic\n    setTimeout(() => setRefreshing(false), 1000);\n  }, []);\n\n  const handleSelect = useCallback((id) => {\n    setSelectedId((prevId) => (prevId === id ? null : id));\n  }, []);\n\n  // Calculate values dependent on state\n  const selectedItem = useMemo(() => {\n    return data.find((item) => item.id === selectedId);\n  }, [data, selectedId]);\n\n  return {\n    data,\n    refreshing,\n    selectedId,\n    selectedItem,\n    handleRefresh,\n    handleSelect,\n  };\n};\n\n// Usage in component\nconst MyListScreen = () => {\n  const { data, refreshing, selectedId, handleRefresh, handleSelect } =\n    useOptimizedList(sourceData);\n\n  return (\n    <FlashList\n      data={data}\n      renderItem={({ item }) => (\n        <ListItem\n          item={item}\n          isSelected={item.id === selectedId}\n          onSelect={handleSelect}\n        />\n      )}\n      refreshing={refreshing}\n      onRefresh={handleRefresh}\n      estimatedItemSize={100}\n    />\n  );\n};\n'})}),"\n",(0,a.jsx)(n.p,{children:"Benefits of custom hooks:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Logic reuse"}),": Reuse data processing and state management logic across screens"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Separation of concerns"}),": Separate data processing logic from display logic"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Testability"}),": Easily write unit tests for data processing logic"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Targeted optimization"}),": Focus on optimizing data processing without affecting UI"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"2-optimizing-data-processing-with-usememo",children:"2. Optimizing Data Processing with useMemo"}),"\n",(0,a.jsxs)(n.p,{children:["Use ",(0,a.jsx)(n.code,{children:"useMemo"})," to avoid recalculating data when unnecessary:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-jsx",children:"const ItemRenderer = ({ item }) => {\n  // Pre-process data once when component mounts or when item changes\n  const processedData = useMemo(() => {\n    console.log(`Processing item ${item.id}...`);\n\n    // Perform expensive data transformations\n    return {\n      formattedTitle: formatTitle(item.title),\n      processedImages: preprocessImages(item.images),\n      metaInfo: extractMetaInfo(item.meta),\n      stats: calculateStats(item.data),\n      searchableText: generateSearchableText(item),\n    };\n  }, [item.id, item.version, item.title, item.images, item.meta, item.data]); // Only recalculate when dependencies change\n\n  return <OptimizedItem data={processedData} />;\n};\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Effective use cases for ",(0,a.jsx)(n.code,{children:"useMemo"}),":"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Complex data transformations"}),": Formatting, calculations, information extraction"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Filtering and sorting lists"}),": Especially for large lists"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Creating complex data structures"}),": Maps, trees, or custom data structures"]}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.strong,{children:"Calculating values dependent on multiple data sources"})}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"Important notes:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Only use ",(0,a.jsx)(n.code,{children:"useMemo"})," for expensive calculations"]}),"\n",(0,a.jsx)(n.li,{children:"Provide accurate dependency arrays"}),"\n",(0,a.jsxs)(n.li,{children:["Avoid overusing ",(0,a.jsx)(n.code,{children:"useMemo"})," for simple calculations"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"3-optimizing-props-stability-with-usememo",children:"3. Optimizing Props Stability with useMemo"}),"\n",(0,a.jsx)(n.p,{children:"Ensure props stability to avoid unnecessary re-renders:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-jsx",children:"const MyList = ({ sourceData, onItemSelect }) => {\n  // Ensure data only changes when necessary\n  const data = useMemo(() => {\n    return sourceData.map((item) => ({\n      ...item,\n      processed: processItem(item), // Pre-process data\n    }));\n  }, [sourceData]);\n\n  // Create complex props once and reuse\n  const listProps = useMemo(\n    () => ({\n      contentContainerStyle: { paddingBottom: 20 },\n      showsVerticalScrollIndicator: false,\n      removeClippedSubviews: true,\n      initialNumToRender: 10,\n      maxToRenderPerBatch: 5,\n      windowSize: 5,\n      keyExtractor: (item) => item.id.toString(),\n    }),\n    []\n  );\n\n  return (\n    <FlashList\n      data={data}\n      renderItem={renderItem}\n      estimatedItemSize={100}\n      {...listProps}\n    />\n  );\n};\n"})}),"\n",(0,a.jsx)(n.h3,{id:"4-using-context-api-effectively",children:"4. Using Context API Effectively"}),"\n",(0,a.jsx)(n.p,{children:"Optimize Context API to avoid unnecessary re-renders:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-jsx",children:'// Split context into smaller functional parts\nconst UserDataContext = createContext();\nconst UserActionsContext = createContext();\n\n// Optimized provider\nconst UserProvider = ({ children }) => {\n  const [userData, setUserData] = useState(initialData);\n\n  // Memoize data to avoid unnecessary re-renders\n  const processedUserData = useMemo(() => {\n    return {\n      displayName: `${userData.firstName} ${userData.lastName}`,\n      formattedJoinDate: formatDate(userData.joinDate),\n      // Other transformations\n    };\n  }, [userData.firstName, userData.lastName, userData.joinDate]);\n\n  // Memoize actions to ensure stability\n  const userActions = useMemo(\n    () => ({\n      updateProfile: (data) => {\n        // Profile update logic\n        setUserData((prev) => ({ ...prev, ...data }));\n      },\n      logout: () => {\n        // Logout logic\n        setUserData(initialData);\n      },\n    }),\n    []\n  );\n\n  return (\n    <UserDataContext.Provider value={processedUserData}>\n      <UserActionsContext.Provider value={userActions}>\n        {children}\n      </UserActionsContext.Provider>\n    </UserDataContext.Provider>\n  );\n};\n\n// Custom hooks to use context\nconst useUserData = () => useContext(UserDataContext);\nconst useUserActions = () => useContext(UserActionsContext);\n\n// Usage in components\nconst ProfileHeader = () => {\n  // Only re-renders when userData changes\n  const userData = useUserData();\n  return <Text>{userData.displayName}</Text>;\n};\n\nconst LogoutButton = () => {\n  // Only re-renders when userActions changes (rarely happens)\n  const { logout } = useUserActions();\n  return <Button title="Logout" onPress={logout} />;\n};\n'})}),"\n",(0,a.jsx)(n.h3,{id:"5-using-selector-pattern",children:"5. Using Selector Pattern"}),"\n",(0,a.jsx)(n.p,{children:"Selector pattern helps efficiently access parts of complex state:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-jsx",children:'// Define selectors\nconst selectFilteredItems = (items, filter) => {\n  return items.filter((item) => {\n    if (filter.category && item.category !== filter.category) return false;\n    if (filter.status && item.status !== filter.status) return false;\n    if (\n      filter.search &&\n      !item.title.toLowerCase().includes(filter.search.toLowerCase())\n    )\n      return false;\n    return true;\n  });\n};\n\nconst selectSortedItems = (items, sortBy, sortOrder) => {\n  return [...items].sort((a, b) => {\n    const factor = sortOrder === "asc" ? 1 : -1;\n    if (sortBy === "date") return factor * (a.date - b.date);\n    if (sortBy === "name") return factor * a.title.localeCompare(b.title);\n    return 0;\n  });\n};\n\n// Usage in component\nconst ItemList = ({ items, filter, sortBy, sortOrder }) => {\n  // Apply selectors in chain, each step is memoized\n  const filteredItems = useMemo(\n    () => selectFilteredItems(items, filter),\n    [items, filter]\n  );\n\n  const sortedAndFilteredItems = useMemo(\n    () => selectSortedItems(filteredItems, sortBy, sortOrder),\n    [filteredItems, sortBy, sortOrder]\n  );\n\n  return (\n    <FlashList\n      data={sortedAndFilteredItems}\n      renderItem={renderItem}\n      estimatedItemSize={100}\n    />\n  );\n};\n'})}),"\n",(0,a.jsx)(n.h3,{id:"6-proxy-based-state-management",children:"6. Proxy-based State Management"}),"\n",(0,a.jsx)(n.p,{children:"Use JavaScript Proxies to detect precise state changes and optimize rendering:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-jsx",children:'// Create observable state with Proxy\nfunction createObservableState(initialState, onChange) {\n  const listeners = new Set();\n\n  if (onChange) {\n    listeners.add(onChange);\n  }\n\n  function notifyChange(path, value, previousValue) {\n    for (const listener of listeners) {\n      listener(path, value, previousValue);\n    }\n  }\n\n  function createProxy(target, path = "") {\n    return new Proxy(target, {\n      get(target, property) {\n        const value = target[property];\n        if (typeof value === "object" && value !== null) {\n          return createProxy(value, path ? `${path}.${property}` : property);\n        }\n        return value;\n      },\n      set(target, property, value) {\n        const previousValue = target[property];\n        if (previousValue !== value) {\n          target[property] = value;\n          const currentPath = path ? `${path}.${property}` : property;\n          notifyChange(currentPath, value, previousValue);\n        }\n        return true;\n      },\n    });\n  }\n\n  return {\n    state: createProxy(initialState),\n    subscribe: (listener) => {\n      listeners.add(listener);\n      return () => listeners.delete(listener);\n    },\n  };\n}\n\n// Component using Proxy-based state\nconst ProxyBasedComponent = ({ item }) => {\n  const [observableState, setObservableState] = useState(() => {\n    return createObservableState(\n      { title: item.title, liked: item.liked, views: item.views },\n      (path, value, previousValue) => {\n        console.log(\n          `Property changed: ${path} from ${previousValue} to ${value}`\n        );\n\n        // Only re-render for specific property changes\n        if (path === "liked" || path === "title") {\n          forceUpdate();\n        }\n\n        // Log but don\'t re-render for analytics properties\n        if (path === "views") {\n          logAnalytics("item_viewed", { itemId: item.id, views: value });\n        }\n      }\n    );\n  });\n\n  // Custom hook for forcing update\n  const forceUpdate = useForceUpdate();\n\n  // Update only necessary properties\n  const handleLike = () => {\n    observableState.state.liked = !observableState.state.liked;\n    // No need to call setState - proxy handles notification\n  };\n\n  const handleView = () => {\n    observableState.state.views += 1;\n    // This won\'t cause re-render due to our path filtering\n  };\n\n  return (\n    <View style={styles.container}>\n      <Text>{observableState.state.title}</Text>\n      <Text>Views: {observableState.state.views}</Text>\n      <Button\n        title={observableState.state.liked ? "Liked" : "Like"}\n        onPress={handleLike}\n      />\n      <Button title="View" onPress={handleView} />\n    </View>\n  );\n};\n\n// Helper hook for force update\nconst useForceUpdate = () => {\n  const [, setTick] = useState(0);\n  return useCallback(() => {\n    setTick((tick) => tick + 1);\n  }, []);\n};\n'})}),"\n",(0,a.jsx)(n.p,{children:"Benefits of Proxy-based state management:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Granular updates"}),": Only re-render when specific properties change"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Deep property tracking"}),": Automatically track nested property changes"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Path-based filtering"}),": Filter which property changes should trigger updates"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Reduced boilerplate"}),": No need for multiple setState calls or action creators"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Transparent API"}),": State can be updated with natural JavaScript syntax"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"7-hybrid-nativejs-rendering-strategy",children:"7. Hybrid Native/JS Rendering Strategy"}),"\n",(0,a.jsx)(n.p,{children:"Combine native and JavaScript rendering for optimal performance:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-jsx",children:'import { NativeModules } from "react-native";\nconst { HybridRenderingManager } = NativeModules;\n\nconst HybridRenderedList = ({ data }) => {\n  // State to track which items should render natively vs in JS\n  const [renderingStrategy, setRenderingStrategy] = useState({});\n  const [isAnalyzing, setIsAnalyzing] = useState(true);\n\n  useEffect(() => {\n    // Analyze which items are better for native rendering\n    setIsAnalyzing(true);\n    HybridRenderingManager.analyzeItems(data)\n      .then((strategies) => {\n        setRenderingStrategy(strategies);\n        setIsAnalyzing(false);\n      })\n      .catch((error) => {\n        console.error("Failed to analyze items:", error);\n        // Fallback to all JS rendering\n        setRenderingStrategy(\n          data.reduce((acc, item) => {\n            acc[item.id] = "js";\n            return acc;\n          }, {})\n        );\n        setIsAnalyzing(false);\n      });\n  }, [data]);\n\n  const renderItem = ({ item, index }) => {\n    // During analysis, render simple placeholders\n    if (isAnalyzing) {\n      return <PlaceholderCell style={styles.item} />;\n    }\n\n    // Based on analysis, choose the appropriate rendering strategy\n    if (renderingStrategy[item.id] === "native") {\n      // Render complex items using native components\n      return (\n        <NativeOptimizedCell\n          item={item}\n          style={styles.item}\n          onPress={() => handleItemPress(item)}\n        />\n      );\n    } else {\n      // Render simple items using JS\n      return (\n        <JSRenderedCell\n          item={item}\n          style={styles.item}\n          onPress={() => handleItemPress(item)}\n        />\n      );\n    }\n  };\n\n  const handleItemPress = useCallback((item) => {\n    // Handle item press\n    console.log("Item pressed:", item.id);\n  }, []);\n\n  // Memoize list props for performance\n  const listProps = useMemo(\n    () => ({\n      removeClippedSubviews: true,\n      maxToRenderPerBatch: 10,\n      updateCellsBatchingPeriod: 50,\n      windowSize: 10,\n      keyExtractor: (item) => item.id,\n    }),\n    []\n  );\n\n  return <FlatList data={data} renderItem={renderItem} {...listProps} />;\n};\n\n// Native module implementation (in native code)\n// Android: HybridRenderingManager.java\n// iOS: HybridRenderingManager.m\n'})}),"\n",(0,a.jsx)(n.p,{children:"Implementation details for native module:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'// Android implementation (simplified)\n@ReactMethod\npublic void analyzeItems(ReadableArray items, Promise promise) {\n  WritableMap strategies = Arguments.createMap();\n\n  for (int i = 0; i < items.size(); i++) {\n    ReadableMap item = items.getMap(i);\n    String id = item.getString("id");\n\n    // Analyze item complexity\n    boolean isComplex = analyzeItemComplexity(item);\n\n    // Determine optimal rendering strategy\n    String strategy = isComplex ? "native" : "js";\n    strategies.putString(id, strategy);\n  }\n\n  promise.resolve(strategies);\n}\n\nprivate boolean analyzeItemComplexity(ReadableMap item) {\n  // Check for complex rendering needs:\n  // 1. Has many nested elements\n  // 2. Contains heavy images\n  // 3. Requires complex layouts\n  // 4. Needs animations\n  // 5. Has custom drawing\n\n  if (item.hasKey("images") && item.getArray("images").size() > 3) {\n    return true;\n  }\n\n  if (item.hasKey("type") &&\n     (item.getString("type").equals("carousel") ||\n      item.getString("type").equals("chart"))) {\n    return true;\n  }\n\n  return false;\n}\n'})}),"\n",(0,a.jsx)(n.p,{children:"Benefits of hybrid rendering:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Optimized performance"}),": Use native rendering for complex items"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Reduced JS bridge traffic"}),": Minimize communication between JS and native"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Better memory management"}),": Native components can better manage memory"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Improved scrolling performance"}),": Native rendering reduces JS thread load"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Adaptive optimization"}),": Dynamically choose rendering strategy based on content"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"advanced-optimization-techniques",children:"Advanced Optimization Techniques"}),"\n",(0,a.jsx)(n.h3,{id:"1-using-memoization-cache",children:"1. Using Memoization Cache"}),"\n",(0,a.jsx)(n.p,{children:"Create cache for expensive calculations:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-jsx",children:'// Utility function to create memoized function\nconst createMemoizedFunction = (\n  fn,\n  getKey = (...args) => JSON.stringify(args)\n) => {\n  const cache = new Map();\n\n  return (...args) => {\n    const key = getKey(...args);\n\n    if (cache.has(key)) {\n      return cache.get(key);\n    }\n\n    const result = fn(...args);\n    cache.set(key, result);\n    return result;\n  };\n};\n\n// Use for expensive calculations\nconst expensiveCalculation = createMemoizedFunction((data, config) => {\n  console.log("Running expensive calculation...");\n  // Complex calculation\n  return processData(data, config);\n});\n\n// In component\nconst ProcessedData = ({ data, config }) => {\n  const result = expensiveCalculation(data, config);\n  return <DataDisplay result={result} />;\n};\n'})}),"\n",(0,a.jsx)(n.h3,{id:"2-using-normalized-state-shape",children:"2. Using Normalized State Shape"}),"\n",(0,a.jsx)(n.p,{children:"Normalize data for efficient access and updates:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-jsx",children:'// Normalized state structure\nconst initialState = {\n  entities: {\n    users: {\n      byId: {\n        user1: { id: "user1", name: "John", roleId: "role1" },\n        user2: { id: "user2", name: "Jane", roleId: "role2" },\n      },\n      allIds: ["user1", "user2"],\n    },\n    roles: {\n      byId: {\n        role1: { id: "role1", name: "Admin" },\n        role2: { id: "role2", name: "User" },\n      },\n      allIds: ["role1", "role2"],\n    },\n  },\n};\n\n// Selectors to access data\nconst selectUserById = (state, userId) => state.entities.users.byId[userId];\nconst selectAllUsers = (state) =>\n  state.entities.users.allIds.map((id) => state.entities.users.byId[id]);\nconst selectUserWithRole = (state, userId) => {\n  const user = selectUserById(state, userId);\n  const role = state.entities.roles.byId[user.roleId];\n  return { ...user, role };\n};\n\n// Reducers to update data\nconst updateUser = (state, user) => ({\n  ...state,\n  entities: {\n    ...state.entities,\n    users: {\n      ...state.entities.users,\n      byId: {\n        ...state.entities.users.byId,\n        [user.id]: {\n          ...state.entities.users.byId[user.id],\n          ...user,\n        },\n      },\n    },\n  },\n});\n'})}),"\n",(0,a.jsx)(n.h3,{id:"3-lazy-state-initialization",children:"3. Lazy State Initialization"}),"\n",(0,a.jsx)(n.p,{children:"Initialize complex state lazily:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-jsx",children:'const ComplexDataComponent = () => {\n  // Use initializer function to avoid calculation on each render\n  const [data, setData] = useState(() => {\n    console.log("Initializing complex data...");\n\n    // Complex calculation only happens once when component mounts\n    const initialData = {};\n\n    // Initialize complex data structure\n    for (let i = 0; i < 1000; i++) {\n      initialData[`item-${i}`] = {\n        id: `item-${i}`,\n        value: Math.random(),\n        processed: heavyProcessing(i),\n      };\n    }\n\n    return initialData;\n  });\n\n  // Component rendering\n  return <View>{/* Render using data */}</View>;\n};\n'})}),"\n",(0,a.jsx)(n.h2,{id:"measuring-data-and-state-management-performance",children:"Measuring Data and State Management Performance"}),"\n",(0,a.jsx)(n.p,{children:"To identify performance issues in data and state management:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"React DevTools Profiler"}),": Analyze render times and render counts"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Performance Monitor"}),": Track CPU and memory usage"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Custom Timing"}),": Add performance markers in code"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Memory Snapshots"}),": Check for memory leaks and excessive memory usage"]}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-jsx",children:"const MeasuredComponent = ({ data }) => {\n  useEffect(() => {\n    // Start timing\n    const startTime = performance.now();\n\n    // Process data\n    const result = processData(data);\n\n    // Log time\n    console.log(`Data processing took ${performance.now() - startTime}ms`);\n  }, [data]);\n\n  // Component rendering\n};\n"})}),"\n",(0,a.jsx)(n.h2,{id:"best-practices-summary",children:"Best Practices Summary"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Create custom hooks"})," to encapsulate data processing and state management logic"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Use useMemo"})," for expensive calculations"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Ensure props stability"})," to avoid unnecessary re-renders"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Optimize Context API"})," by splitting context and memoizing values"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Apply Selector Pattern"})," to efficiently access complex state"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Use Proxy-based state management"})," to detect precise state changes"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Implement hybrid native/JS rendering"})," for optimal performance"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Use immutable data structures"})," to improve comparison performance"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Normalize data"})," for efficient access and updates"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Initialize complex state lazily"})," to avoid unnecessary calculations"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Measure and optimize"})," based on actual performance metrics"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"By applying these techniques, you can significantly improve data and state management performance in your React Native application, leading to smoother user experience and more efficient resource usage."})]})}function m(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>o});var s=t(6540);const a={},i=s.createContext(a);function r(e){const n=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);