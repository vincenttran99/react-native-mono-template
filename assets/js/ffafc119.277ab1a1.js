"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[5992],{2728:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>p,frontMatter:()=>o,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"performance/re-rendering-optimization","title":"Re-rendering Optimization","description":"Optimizing re-renders is one of the most effective ways to improve React Native performance. Unnecessary re-renders can significantly impact your app\'s performance, especially in list components and complex UIs.","source":"@site/docs/performance/re-rendering-optimization.md","sourceDirName":"performance","slug":"/performance/re-rendering-optimization","permalink":"/react-native-mono-template/docs/performance/re-rendering-optimization","draft":false,"unlisted":false,"editUrl":"https://github.com/vincenttran99/react-native-mono-template/edit/main/docs/docs/performance/re-rendering-optimization.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"docs","previous":{"title":"Performance","permalink":"/react-native-mono-template/docs/category/performance"},"next":{"title":"Component Structure Optimization","permalink":"/react-native-mono-template/docs/performance/component-structure-optimization"}}');var s=i(4848),r=i(8453);const o={sidebar_position:1},a="Re-rendering Optimization",c={},l=[{value:"Understanding React&#39;s Rendering Mechanism",id:"understanding-reacts-rendering-mechanism",level:2},{value:"Key Optimization Techniques",id:"key-optimization-techniques",level:2},{value:"1. Memoizing Components with React.memo",id:"1-memoizing-components-with-reactmemo",level:3},{value:"2. Stabilizing Props with useCallback and useMemo",id:"2-stabilizing-props-with-usecallback-and-usememo",level:3},{value:"3. Avoiding Inline Styles and Functions",id:"3-avoiding-inline-styles-and-functions",level:3},{value:"4. Using extraData Correctly in Lists",id:"4-using-extradata-correctly-in-lists",level:3},{value:"5. Creating Fully Cached Components",id:"5-creating-fully-cached-components",level:3},{value:"6. Using PureComponent for Class Components",id:"6-using-purecomponent-for-class-components",level:3},{value:"7. Optimizing Virtual DOM Reconciliation",id:"7-optimizing-virtual-dom-reconciliation",level:3},{value:"8. DOM Pooling Manual",id:"8-dom-pooling-manual",level:3},{value:"9. Ahead-of-Time (AOT) Component Pre-processing",id:"9-ahead-of-time-aot-component-pre-processing",level:3},{value:"10. Component Diffing Optimization",id:"10-component-diffing-optimization",level:3},{value:"11. Snapshot Diffing &amp; Partial Updates",id:"11-snapshot-diffing--partial-updates",level:3},{value:"Performance Measurement",id:"performance-measurement",level:2},{value:"Best Practices Summary",id:"best-practices-summary",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"re-rendering-optimization",children:"Re-rendering Optimization"})}),"\n",(0,s.jsx)(n.p,{children:"Optimizing re-renders is one of the most effective ways to improve React Native performance. Unnecessary re-renders can significantly impact your app's performance, especially in list components and complex UIs."}),"\n",(0,s.jsx)(n.h2,{id:"understanding-reacts-rendering-mechanism",children:"Understanding React's Rendering Mechanism"}),"\n",(0,s.jsx)(n.p,{children:"React's rendering process involves:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Render Phase"}),": Component functions are called, and React builds a virtual DOM"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Reconciliation"}),": React compares the new virtual DOM with the previous one"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Commit Phase"}),": Actual DOM updates are applied"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Optimizing re-renders focuses on minimizing unnecessary work in these phases."}),"\n",(0,s.jsx)(n.h2,{id:"key-optimization-techniques",children:"Key Optimization Techniques"}),"\n",(0,s.jsx)(n.h3,{id:"1-memoizing-components-with-reactmemo",children:"1. Memoizing Components with React.memo"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"React.memo"})," is a higher-order component that prevents re-rendering when props haven't changed."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:"// Without optimization - re-renders on every parent render\nconst Item = ({ item, onPress }) => (\n  <TouchableOpacity onPress={() => onPress(item.id)}>\n    <Text>{item.title}</Text>\n    <Image source={{ uri: item.image }} style={styles.image} />\n  </TouchableOpacity>\n);\n\n// With React.memo - only re-renders when props change\nconst OptimizedItem = React.memo(({ item, onPress }) => (\n  <TouchableOpacity onPress={() => onPress(item.id)}>\n    <Text>{item.title}</Text>\n    <Image source={{ uri: item.image }} style={styles.image} />\n  </TouchableOpacity>\n));\n"})}),"\n",(0,s.jsx)(n.p,{children:"For more complex components, you can provide a custom comparison function:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:"const ComplexItem = React.memo(\n  ({ item }) => (\n    <View style={styles.container}>\n      <Text>{item.title}</Text>\n      <Image source={{ uri: item.imageUrl }} style={styles.image} />\n    </View>\n  ),\n  (prevProps, nextProps) => {\n    // Only re-render if id or version changed\n    return (\n      prevProps.item.id === nextProps.item.id &&\n      prevProps.item.version === nextProps.item.version\n    );\n  }\n);\n"})}),"\n",(0,s.jsx)(n.h3,{id:"2-stabilizing-props-with-usecallback-and-usememo",children:"2. Stabilizing Props with useCallback and useMemo"}),"\n",(0,s.jsx)(n.p,{children:"Functions and objects created during render are new references each time, causing child components to re-render even with React.memo."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:"// Bad practice - new function reference on every render\nconst ParentComponent = () => {\n  const handlePress = (id) => {\n    console.log(`Item ${id} pressed`);\n  };\n\n  return <OptimizedItem item={item} onPress={handlePress} />;\n};\n\n// Good practice - stable function reference\nconst ParentComponent = () => {\n  const handlePress = useCallback((id) => {\n    console.log(`Item ${id} pressed`);\n  }, []); // Dependencies array - re-create only when dependencies change\n\n  return <OptimizedItem item={item} onPress={handlePress} />;\n};\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Similarly, use ",(0,s.jsx)(n.code,{children:"useMemo"})," for computed values and objects:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:"// Stable data reference\nconst data = useMemo(() => {\n  return sourceData.map((item) => ({\n    ...item,\n    processed: processItem(item),\n  }));\n}, [sourceData]);\n"})}),"\n",(0,s.jsx)(n.h3,{id:"3-avoiding-inline-styles-and-functions",children:"3. Avoiding Inline Styles and Functions"}),"\n",(0,s.jsx)(n.p,{children:"Inline styles and functions create new references on every render, defeating memoization."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:'// Bad practice - new style object on every render\nconst BadItem = () => (\n  <View style={{ padding: 10, margin: 5 }}>\n    <TouchableOpacity onPress={() => console.log("Pressed")}>\n      <Text>Item</Text>\n    </TouchableOpacity>\n  </View>\n);\n\n// Good practice - stable style references\nconst styles = StyleSheet.create({\n  container: { padding: 10, margin: 5 },\n});\n\nconst GoodItem = () => (\n  <View style={styles.container}>\n    <TouchableOpacity onPress={handlePress}>\n      <Text>Item</Text>\n    </TouchableOpacity>\n  </View>\n);\n'})}),"\n",(0,s.jsx)(n.h3,{id:"4-using-extradata-correctly-in-lists",children:"4. Using extraData Correctly in Lists"}),"\n",(0,s.jsxs)(n.p,{children:["When using FlatList or FlashList, use ",(0,s.jsx)(n.code,{children:"extraData"})," to trigger re-renders only when necessary:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:"const MyListComponent = () => {\n  const [selectedId, setSelectedId] = useState(null);\n\n  return (\n    <FlashList\n      data={data}\n      renderItem={({ item }) => (\n        <ItemComponent\n          item={item}\n          isSelected={item.id === selectedId}\n          onSelect={setSelectedId}\n        />\n      )}\n      estimatedItemSize={100}\n      extraData={selectedId} // Only re-render when selectedId changes\n    />\n  );\n};\n"})}),"\n",(0,s.jsx)(n.h3,{id:"5-creating-fully-cached-components",children:"5. Creating Fully Cached Components"}),"\n",(0,s.jsx)(n.p,{children:"For truly static components that never need to update:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:'const StaticHeader = React.memo(\n  ({ title }) => (\n    <View style={styles.headerContainer}>\n      <Text style={styles.title} numberOfLines={1} ellipsizeMode="tail">\n        {title}\n      </Text>\n    </View>\n  ),\n  () => true // Always return true = never re-render\n);\n'})}),"\n",(0,s.jsx)(n.h3,{id:"6-using-purecomponent-for-class-components",children:"6. Using PureComponent for Class Components"}),"\n",(0,s.jsxs)(n.p,{children:["For class components, extend ",(0,s.jsx)(n.code,{children:"PureComponent"})," or implement ",(0,s.jsx)(n.code,{children:"shouldComponentUpdate"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:"class OptimizedItemComponent extends React.PureComponent {\n  // PureComponent implements shouldComponentUpdate with shallow comparison\n\n  render() {\n    const { item } = this.props;\n    return (\n      <View style={styles.container}>\n        <Text>{item.title}</Text>\n        <Image source={{ uri: item.imageUrl }} style={styles.image} />\n      </View>\n    );\n  }\n}\n\n// Or with custom update logic\nclass CustomOptimizedComponent extends React.Component {\n  shouldComponentUpdate(nextProps) {\n    // Custom logic - only update when specific props change\n    return (\n      this.props.item.id !== nextProps.item.id ||\n      this.props.item.updated !== nextProps.item.updated\n    );\n  }\n\n  render() {\n    // Component rendering logic\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"7-optimizing-virtual-dom-reconciliation",children:"7. Optimizing Virtual DOM Reconciliation"}),"\n",(0,s.jsx)(n.p,{children:"Providing stable keys helps React's reconciliation process:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:"const ReconciliationOptimized = ({ item }) => {\n  return (\n    <View>\n      {item.elements.map((el) => (\n        <Element\n          key={`${item.id}-${el.id}`} // Structured and stable key\n          data={el}\n        />\n      ))}\n    </View>\n  );\n};\n"})}),"\n",(0,s.jsx)(n.h3,{id:"8-dom-pooling-manual",children:"8. DOM Pooling Manual"}),"\n",(0,s.jsx)(n.p,{children:"DOM Pooling is a technique that manages and reuses DOM elements to minimize the creation and destruction of elements, which can be expensive operations:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:"class DOMPoolManager {\n  constructor(size = 50) {\n    this.views = Array(size)\n      .fill()\n      .map(() => createViewRef());\n    this.inUse = new Set();\n  }\n\n  getView() {\n    const availableView = this.views.find((v) => !this.inUse.has(v));\n    if (availableView) {\n      this.inUse.add(availableView);\n      return availableView;\n    }\n    return createViewRef(); // Fallback\n  }\n\n  releaseView(view) {\n    this.inUse.delete(view);\n  }\n}\n\n// Usage\nconst viewPool = new DOMPoolManager();\n\nconst PooledView = ({ item, onUnmount }) => {\n  const viewRef = useRef(null);\n\n  useEffect(() => {\n    viewRef.current = viewPool.getView();\n\n    return () => {\n      viewPool.releaseView(viewRef.current);\n      onUnmount && onUnmount();\n    };\n  }, []);\n\n  return (\n    <View ref={viewRef} style={styles.container}>\n      <Text>{item.title}</Text>\n    </View>\n  );\n};\n"})}),"\n",(0,s.jsx)(n.p,{children:"Benefits of DOM pooling:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Reduces garbage collection overhead"}),"\n",(0,s.jsx)(n.li,{children:"Minimizes layout thrashing"}),"\n",(0,s.jsx)(n.li,{children:"Improves performance in high-frequency update scenarios"}),"\n",(0,s.jsx)(n.li,{children:"Particularly effective for lists with many items being added/removed"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"9-ahead-of-time-aot-component-pre-processing",children:"9. Ahead-of-Time (AOT) Component Pre-processing"}),"\n",(0,s.jsx)(n.p,{children:"Using babel plugins to pre-process components at build time can significantly improve runtime performance:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:"// babel-plugin-transform-react-components.js\nmodule.exports = function (babel) {\n  const { types: t } = babel;\n\n  return {\n    visitor: {\n      FunctionDeclaration(path) {\n        // Transform React component for better performance\n        if (isReactComponent(path.node)) {\n          // Pre-compute static parts\n          // Optimize render logic\n        }\n      },\n    },\n  };\n};\n\n// Component optimized at build time\nfunction ItemComponent({ item }) {\n  // Build tool will analyze and optimize this component before bundling\n  return (\n    <View style={styles.container}>\n      <Text>{item.title}</Text>\n    </View>\n  );\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"Benefits of AOT pre-processing:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Moves computation from runtime to build time"}),"\n",(0,s.jsx)(n.li,{children:"Optimizes component structure before execution"}),"\n",(0,s.jsx)(n.li,{children:"Can automatically apply best practices"}),"\n",(0,s.jsx)(n.li,{children:"Reduces bundle size by eliminating redundant code"}),"\n",(0,s.jsx)(n.li,{children:"Improves startup performance"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"10-component-diffing-optimization",children:"10. Component Diffing Optimization"}),"\n",(0,s.jsx)(n.p,{children:"Deep prop comparison techniques can avoid unnecessary rendering:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:'const ComponentDiffOptimizer = ({ component, props }) => {\n  const cachedPropsRef = useRef(props);\n  const shouldUpdate = useRef(true);\n  const [renderKey, setRenderKey] = useState(0);\n\n  // Deep prop comparison with optimizations\n  useEffect(() => {\n    const diffs = getDeepPropChanges(cachedPropsRef.current, props);\n\n    // Only signal update for non-trivial prop changes\n    if (diffs.some((diff) => isSignificantPropChange(diff))) {\n      shouldUpdate.current = true;\n      setRenderKey((prev) => prev + 1);\n    }\n\n    cachedPropsRef.current = { ...props };\n  }, [props]);\n\n  // Only render if there\'s a meaningful change\n  if (!shouldUpdate.current) {\n    return null;\n  }\n\n  shouldUpdate.current = false;\n  const Component = component;\n  return <Component key={renderKey} {...props} />;\n};\n\n// Helper for identifying significant prop changes\nconst isSignificantPropChange = (diff) => {\n  const { path, oldValue, newValue } = diff;\n\n  // Skip style changes that don\'t affect layout\n  if (path.includes("style")) {\n    if (path.includes("color") || path.includes("backgroundColor")) {\n      return false;\n    }\n  }\n\n  // Skip certain props that don\'t affect rendering\n  if (path.includes("onLayout") || path.includes("testID")) {\n    return false;\n  }\n\n  return true;\n};\n'})}),"\n",(0,s.jsx)(n.p,{children:"Benefits of component diffing:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Provides fine-grained control over re-renders"}),"\n",(0,s.jsx)(n.li,{children:"Can ignore cosmetic changes that don't affect layout"}),"\n",(0,s.jsx)(n.li,{children:"Allows custom logic for determining significant changes"}),"\n",(0,s.jsx)(n.li,{children:"Works well for complex nested props"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"11-snapshot-diffing--partial-updates",children:"11. Snapshot Diffing & Partial Updates"}),"\n",(0,s.jsx)(n.p,{children:"Instead of re-rendering an entire component, this technique only updates the changed parts:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:'class SnapshotDiffingComponent extends React.Component {\n  constructor(props) {\n    super(props);\n    this.lastSnapshot = null;\n    this.viewRefs = new Map();\n  }\n\n  shouldComponentUpdate() {\n    // Always return false to handle updates manually\n    return false;\n  }\n\n  getSnapshotFromProps(props) {\n    // Generate a lightweight representation of the component state\n    return {\n      title: props.item.title,\n      subtitle: props.item.subtitle,\n      imageUrl: props.item.imageUrl,\n      isActive: props.isActive,\n    };\n  }\n\n  componentDidMount() {\n    this.lastSnapshot = this.getSnapshotFromProps(this.props);\n    this.forceFullRender();\n  }\n\n  componentDidUpdate(prevProps) {\n    const newSnapshot = this.getSnapshotFromProps(this.props);\n    const diffs = this.diffSnapshots(this.lastSnapshot, newSnapshot);\n\n    if (diffs.length > 0) {\n      // Apply only the necessary updates\n      this.applyPartialUpdates(diffs);\n      this.lastSnapshot = newSnapshot;\n    }\n  }\n\n  diffSnapshots(oldSnapshot, newSnapshot) {\n    const diffs = [];\n\n    Object.keys(newSnapshot).forEach((key) => {\n      if (oldSnapshot[key] !== newSnapshot[key]) {\n        diffs.push({ key, value: newSnapshot[key] });\n      }\n    });\n\n    return diffs;\n  }\n\n  applyPartialUpdates(diffs) {\n    diffs.forEach((diff) => {\n      const updateMethod = this[`update${capitalize(diff.key)}`];\n      if (updateMethod) {\n        updateMethod.call(this, diff.value);\n      }\n    });\n  }\n\n  // Update methods for each property\n  updateTitle(newTitle) {\n    const titleRef = this.viewRefs.get("title");\n    if (titleRef) {\n      titleRef.setNativeProps({ text: newTitle });\n    }\n  }\n\n  updateIsActive(isActive) {\n    const containerRef = this.viewRefs.get("container");\n    if (containerRef) {\n      containerRef.setNativeProps({\n        style: isActive ? styles.activeContainer : styles.container,\n      });\n    }\n  }\n\n  // Full render as fallback\n  forceFullRender() {\n    // Implement full rendering logic\n  }\n\n  render() {\n    return (\n      <View\n        ref={(ref) => this.viewRefs.set("container", ref)}\n        style={this.props.isActive ? styles.activeContainer : styles.container}\n      >\n        <Text ref={(ref) => this.viewRefs.set("title", ref)}>\n          {this.props.item.title}\n        </Text>\n        <Text ref={(ref) => this.viewRefs.set("subtitle", ref)}>\n          {this.props.item.subtitle}\n        </Text>\n        <Image\n          ref={(ref) => this.viewRefs.set("image", ref)}\n          source={{ uri: this.props.item.imageUrl }}\n          style={styles.image}\n        />\n      </View>\n    );\n  }\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"Benefits of snapshot diffing:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Minimizes DOM operations by only updating what changed"}),"\n",(0,s.jsx)(n.li,{children:"Bypasses React's reconciliation for performance-critical components"}),"\n",(0,s.jsx)(n.li,{children:"Particularly effective for components with frequent small updates"}),"\n",(0,s.jsx)(n.li,{children:"Can significantly reduce rendering overhead in complex UIs"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"performance-measurement",children:"Performance Measurement"}),"\n",(0,s.jsx)(n.p,{children:"To identify unnecessary re-renders:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Use the React DevTools Profiler"}),"\n",(0,s.jsx)(n.li,{children:"Add console logs in render functions"}),"\n",(0,s.jsxs)(n.li,{children:["Use the ",(0,s.jsx)(n.code,{children:"why-did-you-render"})," library"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"best-practices-summary",children:"Best Practices Summary"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["Memoize components with ",(0,s.jsx)(n.code,{children:"React.memo"})]}),"\n",(0,s.jsxs)(n.li,{children:["Stabilize props with ",(0,s.jsx)(n.code,{children:"useCallback"})," and ",(0,s.jsx)(n.code,{children:"useMemo"})]}),"\n",(0,s.jsx)(n.li,{children:"Avoid inline styles and functions"}),"\n",(0,s.jsxs)(n.li,{children:["Use ",(0,s.jsx)(n.code,{children:"extraData"})," correctly in list components"]}),"\n",(0,s.jsx)(n.li,{children:"Create fully cached components when appropriate"}),"\n",(0,s.jsxs)(n.li,{children:["Use ",(0,s.jsx)(n.code,{children:"PureComponent"})," or ",(0,s.jsx)(n.code,{children:"shouldComponentUpdate"})," for class components"]}),"\n",(0,s.jsx)(n.li,{children:"Provide stable, structured keys for lists"}),"\n",(0,s.jsx)(n.li,{children:"Implement DOM pooling for frequently changing lists"}),"\n",(0,s.jsx)(n.li,{children:"Use AOT component pre-processing for complex components"}),"\n",(0,s.jsx)(n.li,{children:"Apply component diffing for fine-grained update control"}),"\n",(0,s.jsx)(n.li,{children:"Implement snapshot diffing for performance-critical components"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"By implementing these techniques, you can significantly reduce unnecessary re-renders and improve your app's performance."})]})}function p(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>o,x:()=>a});var t=i(6540);const s={},r=t.createContext(s);function o(e){const n=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);