"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[912],{1796:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>a,default:()=>m,frontMatter:()=>r,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"performance/flashlist-optimization","title":"FlashList and List Optimization","description":"Optimizing list components is crucial for React Native performance as they often represent the most complex and resource-intensive parts of mobile applications. This guide focuses on advanced techniques for optimizing FlashList and other list components.","source":"@site/docs/performance/flashlist-optimization.md","sourceDirName":"performance","slug":"/performance/flashlist-optimization","permalink":"/react-native-mono-template/docs/performance/flashlist-optimization","draft":false,"unlisted":false,"editUrl":"https://github.com/vincenttran99/react-native-mono-template/edit/main/docs/docs/performance/flashlist-optimization.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"docs","previous":{"title":"Component Structure Optimization","permalink":"/react-native-mono-template/docs/performance/component-structure-optimization"},"next":{"title":"Heavy Task Processing","permalink":"/react-native-mono-template/docs/performance/heavy-task-processing"}}');var s=i(4848),l=i(8453);const r={sidebar_position:3},a="FlashList and List Optimization",o={},d=[{value:"Why List Optimization Matters",id:"why-list-optimization-matters",level:2},{value:"Key Optimization Techniques",id:"key-optimization-techniques",level:2},{value:"1. Configuring Accurate Item Size Estimation",id:"1-configuring-accurate-item-size-estimation",level:3},{value:"2. Optimizing Cell Reuse with getItemType",id:"2-optimizing-cell-reuse-with-getitemtype",level:3},{value:"3. Controlling Cell Reuse with CellRendererComponent",id:"3-controlling-cell-reuse-with-cellrenderercomponent",level:3},{value:"4. Configuring Viewability for Optimal Performance",id:"4-configuring-viewability-for-optimal-performance",level:3},{value:"5. Using removeClippedSubviews and windowSize for Large Lists",id:"5-using-removeclippedsubviews-and-windowsize-for-large-lists",level:3},{value:"6. Using getItemLayout for Fixed-Size Items",id:"6-using-getitemlayout-for-fixed-size-items",level:3},{value:"7. Spatial Hashmap for Optimized Lists",id:"7-spatial-hashmap-for-optimized-lists",level:3},{value:"8. Memory-mapped Lists with VirtualizedList Internals",id:"8-memory-mapped-lists-with-virtualizedlist-internals",level:3},{value:"9. Quantum VirtualizedList (Progressive Loading)",id:"9-quantum-virtualizedlist-progressive-loading",level:3},{value:"Measuring List Performance",id:"measuring-list-performance",level:2},{value:"Best Practices Summary",id:"best-practices-summary",level:2},{value:"Advanced Techniques",id:"advanced-techniques",level:2},{value:"Virtualized Loading Patterns",id:"virtualized-loading-patterns",level:3},{value:"Data Windowing",id:"data-windowing",level:3}];function c(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,l.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"flashlist-and-list-optimization",children:"FlashList and List Optimization"})}),"\n",(0,s.jsx)(n.p,{children:"Optimizing list components is crucial for React Native performance as they often represent the most complex and resource-intensive parts of mobile applications. This guide focuses on advanced techniques for optimizing FlashList and other list components."}),"\n",(0,s.jsx)(n.h2,{id:"why-list-optimization-matters",children:"Why List Optimization Matters"}),"\n",(0,s.jsx)(n.p,{children:"Lists in React Native can cause performance issues due to:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Rendering many items"}),": Creating and laying out numerous components"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Frequent re-renders"}),": Updating items as data changes"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Memory consumption"}),": Keeping many items in memory"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Layout calculations"}),": Computing positions for dynamic content"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"FlashList addresses many of these concerns, but requires proper configuration to achieve optimal performance."}),"\n",(0,s.jsx)(n.h2,{id:"key-optimization-techniques",children:"Key Optimization Techniques"}),"\n",(0,s.jsx)(n.h3,{id:"1-configuring-accurate-item-size-estimation",children:"1. Configuring Accurate Item Size Estimation"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"estimatedItemSize"})," and ",(0,s.jsx)(n.code,{children:"overrideItemLayout"})," properties are critical for FlashList performance:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:'<FlashList\n  data={data}\n  renderItem={renderItem}\n  estimatedItemSize={100} // Accurate size estimation\n  overrideItemLayout={(layout, item) => {\n    // Precise size calculation based on item type\n    layout.size =\n      item.type === "large" ? 150 : item.type === "medium" ? 100 : 80;\n  }}\n/>\n'})}),"\n",(0,s.jsx)(n.p,{children:"Best practices:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Measure your actual item sizes and use the average as ",(0,s.jsx)(n.code,{children:"estimatedItemSize"})]}),"\n",(0,s.jsxs)(n.li,{children:["For variable-sized items, implement ",(0,s.jsx)(n.code,{children:"overrideItemLayout"})," to provide precise measurements"]}),"\n",(0,s.jsx)(n.li,{children:"Group similar-sized items together when possible"}),"\n",(0,s.jsx)(n.li,{children:"Consider using fixed heights for list items when design allows"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"2-optimizing-cell-reuse-with-getitemtype",children:"2. Optimizing Cell Reuse with getItemType"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"getItemType"})," property helps FlashList reuse cells more efficiently:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:"<FlashList\n  data={data}\n  renderItem={({ item }) => {\n    switch (item.type) {\n      case \"header\":\n        return <HeaderItem item={item} />;\n      case \"product\":\n        return <ProductItem item={item} />;\n      case \"ad\":\n        return <AdItem item={item} />;\n      default:\n        return <StandardItem item={item} />;\n    }\n  }}\n  estimatedItemSize={100}\n  getItemType={(item) => {\n    // Categorize items by type for better cell reuse\n    return item.type; // e.g., 'header', 'product', 'ad', 'standard'\n  }}\n/>\n"})}),"\n",(0,s.jsx)(n.p,{children:"Benefits:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Cells are reused within the same type pool"}),"\n",(0,s.jsx)(n.li,{children:"Reduces initialization overhead"}),"\n",(0,s.jsx)(n.li,{children:"Minimizes layout recalculations"}),"\n",(0,s.jsx)(n.li,{children:"Improves scrolling performance"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"3-controlling-cell-reuse-with-cellrenderercomponent",children:"3. Controlling Cell Reuse with CellRendererComponent"}),"\n",(0,s.jsxs)(n.p,{children:["For advanced control over cell reuse, implement a custom ",(0,s.jsx)(n.code,{children:"CellRendererComponent"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:'const MyCellRenderer = React.memo(\n  ({ item, index, children, style, onLayout }) => {\n    // Log when cells are being reused\n    console.log(`Cell for item ${item.id} (type: ${item.type}) being prepared`);\n\n    // Add custom logic for cell preparation or cleanup\n    useEffect(() => {\n      // Setup code when cell is reused\n      return () => {\n        // Cleanup code when cell is recycled\n      };\n    }, [item.id]);\n\n    return (\n      <View\n        style={[\n          style,\n          item.type === "important" ? styles.highlightedCell : null,\n        ]}\n        onLayout={onLayout}\n      >\n        {children}\n      </View>\n    );\n  }\n);\n\n<FlashList\n  data={data}\n  renderItem={renderItem}\n  estimatedItemSize={100}\n  CellRendererComponent={MyCellRenderer}\n/>;\n'})}),"\n",(0,s.jsx)(n.p,{children:"Use cases:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Adding cell-level animations or transitions"}),"\n",(0,s.jsx)(n.li,{children:"Implementing custom cell preparation logic"}),"\n",(0,s.jsx)(n.li,{children:"Monitoring cell reuse patterns"}),"\n",(0,s.jsx)(n.li,{children:"Adding cell-specific styling or behavior"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"4-configuring-viewability-for-optimal-performance",children:"4. Configuring Viewability for Optimal Performance"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"viewabilityConfig"})," and ",(0,s.jsx)(n.code,{children:"maintainVisibleContentPosition"})," properties help control when and how items are rendered:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:'<FlashList\n  data={data}\n  renderItem={renderItem}\n  estimatedItemSize={100}\n  viewabilityConfig={{\n    // Only consider items "viewable" when at least 50% visible\n    minimumViewTime: 300, // ms before considering item as "viewed"\n    viewAreaCoveragePercentThreshold: 50,\n    // Alternative: itemVisiblePercentThreshold: 50,\n    waitForInteraction: true, // Wait for user interaction before firing viewability callbacks\n  }}\n  maintainVisibleContentPosition={{\n    minIndexForVisible: 0,\n    autoscrollToTopThreshold: 10, // Auto-scroll to top when within 10px\n  }}\n  onViewableItemsChanged={onViewableItemsChanged}\n/>\n'})}),"\n",(0,s.jsx)(n.p,{children:"Benefits:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Control when viewability callbacks fire"}),"\n",(0,s.jsx)(n.li,{children:"Optimize content loading based on visibility"}),"\n",(0,s.jsx)(n.li,{children:"Maintain scroll position during data updates"}),"\n",(0,s.jsx)(n.li,{children:"Improve perceived performance"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"5-using-removeclippedsubviews-and-windowsize-for-large-lists",children:"5. Using removeClippedSubviews and windowSize for Large Lists"}),"\n",(0,s.jsx)(n.p,{children:"For very large lists, optimize memory usage with these properties:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:"<FlashList\n  data={largeDataset}\n  renderItem={renderItem}\n  estimatedItemSize={100}\n  removeClippedSubviews={true} // Detach off-screen views from the view hierarchy\n  windowSize={5} // Render items within 5 screen lengths (above and below)\n  maxToRenderPerBatch={10} // Limit items rendered in each batch\n  updateCellsBatchingPeriod={50} // ms between batch renders\n/>\n"})}),"\n",(0,s.jsx)(n.p,{children:"When to use:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"removeClippedSubviews"}),": For lists with hundreds or thousands of items"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"windowSize"}),": Adjust based on scroll speed and available memory"]}),"\n",(0,s.jsxs)(n.li,{children:["Smaller ",(0,s.jsx)(n.code,{children:"windowSize"})," values save memory but may cause blank areas during fast scrolling"]}),"\n",(0,s.jsx)(n.li,{children:"Larger values provide smoother scrolling but consume more memory"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"6-using-getitemlayout-for-fixed-size-items",children:"6. Using getItemLayout for Fixed-Size Items"}),"\n",(0,s.jsxs)(n.p,{children:["For lists with fixed-size items, ",(0,s.jsx)(n.code,{children:"getItemLayout"})," provides significant performance benefits:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:"<FlashList\n  data={data}\n  renderItem={renderItem}\n  estimatedItemSize={120}\n  getItemLayout={(data, index) => ({\n    length: 120, // Fixed height for each item\n    offset: 120 * index, // Position calculation\n    index,\n  })}\n/>\n"})}),"\n",(0,s.jsx)(n.p,{children:"Benefits:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Eliminates the need for measurement"}),"\n",(0,s.jsx)(n.li,{children:"Enables immediate scrolling to any position"}),"\n",(0,s.jsx)(n.li,{children:"Reduces layout calculation overhead"}),"\n",(0,s.jsx)(n.li,{children:"Improves initial render time"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"For variable-height items with predictable patterns:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:"const getItemLayout = (data, index) => {\n  // Example: Every 5th item is a header with different height\n  const isHeader = index % 5 === 0;\n  const itemHeight = isHeader ? 150 : 100;\n\n  // Calculate offset based on previous items\n  let offset = 0;\n  for (let i = 0; i < index; i++) {\n    offset += i % 5 === 0 ? 150 : 100;\n  }\n\n  return { length: itemHeight, offset, index };\n};\n"})}),"\n",(0,s.jsx)(n.h3,{id:"7-spatial-hashmap-for-optimized-lists",children:"7. Spatial Hashmap for Optimized Lists"}),"\n",(0,s.jsx)(n.p,{children:"Using spatial hashmaps allows you to render only items that are within the viewport, significantly improving performance for complex lists:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:'// Spatial hashmap implementation for optimized rendering\nclass SpatialViewport {\n  constructor(cellSize = 100) {\n    this.items = new Map();\n    this.cells = new Map();\n    this.cellSize = cellSize;\n  }\n\n  addItem(id, bounds) {\n    this.items.set(id, bounds);\n\n    const minCellX = Math.floor(bounds.x / this.cellSize);\n    const maxCellX = Math.floor((bounds.x + bounds.width) / this.cellSize);\n    const minCellY = Math.floor(bounds.y / this.cellSize);\n    const maxCellY = Math.floor((bounds.y + bounds.height) / this.cellSize);\n\n    for (let x = minCellX; x <= maxCellX; x++) {\n      for (let y = minCellY; y <= maxCellY; y++) {\n        const cellKey = `${x},${y}`;\n        if (!this.cells.has(cellKey)) {\n          this.cells.set(cellKey, new Set());\n        }\n        this.cells.get(cellKey).add(id);\n      }\n    }\n  }\n\n  getItemsInViewport(viewport) {\n    const minCellX = Math.floor(viewport.x / this.cellSize);\n    const maxCellX = Math.floor((viewport.x + viewport.width) / this.cellSize);\n    const minCellY = Math.floor(viewport.y / this.cellSize);\n    const maxCellY = Math.floor((viewport.y + viewport.height) / this.cellSize);\n\n    const itemsInView = new Set();\n\n    for (let x = minCellX; x <= maxCellX; x++) {\n      for (let y = minCellY; y <= maxCellY; y++) {\n        const cellKey = `${x},${y}`;\n        const itemsInCell = this.cells.get(cellKey);\n        if (itemsInCell) {\n          for (const id of itemsInCell) {\n            itemsInView.add(id);\n          }\n        }\n      }\n    }\n\n    return Array.from(itemsInView);\n  }\n}\n\n// Usage with FlashList\nconst SpatialOptimizedList = ({ data }) => {\n  const [visibleItems, setVisibleItems] = useState([]);\n  const spatialViewport = useRef(new SpatialViewport(100)).current;\n  const listRef = useRef(null);\n\n  // Update spatial data when items change\n  useEffect(() => {\n    data.forEach((item, index) => {\n      // Estimate item position based on index and size\n      const bounds = {\n        x: 0,\n        y: index * 100, // Estimated height\n        width: Dimensions.get("window").width,\n        height: 100,\n      };\n      spatialViewport.addItem(item.id, bounds);\n    });\n  }, [data]);\n\n  // Update visible items when scroll position changes\n  const handleScroll = (event) => {\n    const { y, height } = event.nativeEvent.contentOffset;\n    const viewport = {\n      x: 0,\n      y,\n      width: Dimensions.get("window").width,\n      height: height + Dimensions.get("window").height,\n    };\n\n    const visibleIds = spatialViewport.getItemsInViewport(viewport);\n    const newVisibleItems = visibleIds\n      .map((id) => data.find((item) => item.id === id))\n      .filter(Boolean);\n\n    setVisibleItems(newVisibleItems);\n  };\n\n  return (\n    <FlashList\n      ref={listRef}\n      data={visibleItems}\n      renderItem={({ item }) => <ListItem item={item} />}\n      estimatedItemSize={100}\n      onScroll={handleScroll}\n      scrollEventThrottle={16}\n    />\n  );\n};\n'})}),"\n",(0,s.jsx)(n.p,{children:"Benefits of spatial hashmaps:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Precise visibility detection"}),": Only render items that are actually visible"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Efficient for complex layouts"}),": Works well with grid layouts and non-linear arrangements"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Reduced rendering overhead"}),": Minimizes the number of components in the render tree"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Improved scrolling performance"}),": Less work during scroll events"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Memory efficiency"}),": Only keeps necessary items in memory"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"When to use spatial hashmaps:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Complex grid layouts with variable-sized items"}),"\n",(0,s.jsx)(n.li,{children:"Maps and spatial visualizations"}),"\n",(0,s.jsx)(n.li,{children:"Virtual canvases with many elements"}),"\n",(0,s.jsx)(n.li,{children:"Any list where items have 2D positions rather than just a linear arrangement"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"8-memory-mapped-lists-with-virtualizedlist-internals",children:"8. Memory-mapped Lists with VirtualizedList Internals"}),"\n",(0,s.jsx)(n.p,{children:"For extremely large datasets, memory mapping techniques can significantly improve performance:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:"// Memory-mapped list implementation for extremely large datasets\nclass VirtualMemoryList extends React.Component {\n  constructor(props) {\n    super(props);\n\n    // Pre-allocate memory for item size calculations\n    this.itemSizeCache = new Array(props.data.length);\n    this.listRef = React.createRef();\n\n    // Only load a small number of items into memory\n    this.windowSize = 50;\n    this.state = {\n      visibleStartIndex: 0,\n      visibleEndIndex: this.windowSize,\n    };\n  }\n\n  getItemLayout = (data, index) => {\n    // Use cache if available\n    if (this.itemSizeCache[index] != null) {\n      return {\n        length: this.itemSizeCache[index],\n        offset: this.itemSizeCache\n          .slice(0, index)\n          .reduce((sum, size) => sum + (size || 0), 0),\n        index,\n      };\n    }\n\n    // Fallback to estimatedItemSize\n    const estimatedSize = this.props.estimatedItemSize || 100;\n    return {\n      length: estimatedSize,\n      offset: estimatedSize * index,\n      index,\n    };\n  };\n\n  onViewableItemsChanged = ({ viewableItems }) => {\n    if (viewableItems.length > 0) {\n      const firstVisible = viewableItems[0].index;\n      const lastVisible = viewableItems[viewableItems.length - 1].index;\n\n      // Update window with buffer\n      const buffer = Math.floor(this.windowSize / 3);\n      this.setState({\n        visibleStartIndex: Math.max(0, firstVisible - buffer),\n        visibleEndIndex: Math.min(\n          this.props.data.length - 1,\n          lastVisible + buffer\n        ),\n      });\n    }\n  };\n\n  render() {\n    const { data, renderItem, ...restProps } = this.props;\n    const { visibleStartIndex, visibleEndIndex } = this.state;\n\n    // Only render items in the current window\n    const visibleData = data.slice(visibleStartIndex, visibleEndIndex + 1);\n\n    return (\n      <VirtualizedList\n        ref={this.listRef}\n        data={visibleData}\n        renderItem={({ item, index }) =>\n          renderItem({\n            item,\n            index: index + visibleStartIndex,\n          })\n        }\n        getItemCount={() => visibleData.length}\n        getItem={(data, index) => data[index]}\n        getItemLayout={this.getItemLayout}\n        onViewableItemsChanged={this.onViewableItemsChanged}\n        windowSize={5} // VirtualizedList's own window size\n        updateCellsBatchingPeriod={50} // Batch updates\n        maxToRenderPerBatch={10} // Limit batch size\n        removeClippedSubviews={true}\n        maintainVisibleContentPosition={{\n          minIndexForVisible: 0,\n          autoscrollToTopThreshold: 10,\n        }}\n        {...restProps}\n      />\n    );\n  }\n}\n\n// Usage\nconst MemoryEfficientList = ({ data }) => (\n  <VirtualMemoryList\n    data={data}\n    renderItem={({ item, index }) => <ListItem item={item} index={index} />}\n    estimatedItemSize={100}\n    keyExtractor={(item) => item.id}\n  />\n);\n"})}),"\n",(0,s.jsx)(n.p,{children:"Benefits of memory-mapped lists:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Extreme memory efficiency"}),": Only keeps a small window of items in memory"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Handles massive datasets"}),": Can work with millions of items"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Reduced initialization time"}),": Only processes visible items"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Smooth scrolling"}),": Maintains performance even with very large datasets"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Dynamic window sizing"}),": Adjusts based on scroll behavior"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"When to use memory mapping:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Lists with thousands or millions of items"}),"\n",(0,s.jsx)(n.li,{children:"Applications with memory constraints"}),"\n",(0,s.jsx)(n.li,{children:"Data visualization of large datasets"}),"\n",(0,s.jsx)(n.li,{children:"Infinite scrolling implementations"}),"\n",(0,s.jsx)(n.li,{children:"When users need to navigate quickly through large datasets"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"9-quantum-virtualizedlist-progressive-loading",children:"9. Quantum VirtualizedList (Progressive Loading)"}),"\n",(0,s.jsx)(n.p,{children:"This advanced technique renders list items with different quality levels based on their visibility:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:'const QuantumVirtualizedList = ({ data, renderItem }) => {\n  // Track data visibility with IntersectionObserver-like functionality\n  const [visibleIndices, setVisibleIndices] = useState(new Set([0, 1, 2]));\n  const listRef = useRef(null);\n\n  const quantumRenderItem = ({ item, index }) => {\n    // Render different quality based on visibility\n    if (visibleIndices.has(index)) {\n      // High-quality rendering for visible items\n      return renderItem({ item, index });\n    } else {\n      // Low-quality placeholder for invisible items\n      const distance = getDistanceFromVisibleItems(\n        index,\n        Array.from(visibleIndices)\n      );\n\n      if (distance < 5) {\n        // Medium quality for nearby items\n        return (\n          <MediumQualityPlaceholder\n            item={item}\n            onLayout={(e) => updateItemMetrics(index, e.nativeEvent.layout)}\n          />\n        );\n      } else {\n        // Ultra-lightweight placeholder for far items\n        return (\n          <LightweightPlaceholder\n            height={estimateHeightForItem(item)}\n            onLayout={(e) => updateItemMetrics(index, e.nativeEvent.layout)}\n          />\n        );\n      }\n    }\n  };\n\n  // Update visibility data based on scroll position\n  const handleViewableItemsChanged = ({ viewableItems }) => {\n    setVisibleIndices(new Set(viewableItems.map((v) => v.index)));\n  };\n\n  return (\n    <VirtualizedList\n      ref={listRef}\n      data={data}\n      renderItem={quantumRenderItem}\n      onViewableItemsChanged={handleViewableItemsChanged}\n      getItemCount={() => data.length}\n      getItem={(data, index) => data[index]}\n      viewabilityConfig={{\n        minimumViewTime: 100,\n        viewAreaCoveragePercentThreshold: 20,\n      }}\n    />\n  );\n};\n\n// Helper components for different quality levels\nconst MediumQualityPlaceholder = ({ item, onLayout }) => (\n  <View style={styles.mediumQualityItem} onLayout={onLayout}>\n    <View style={styles.avatarPlaceholder} />\n    <View style={styles.textPlaceholder}>\n      <View style={styles.titlePlaceholder} />\n      <View style={styles.subtitlePlaceholder} />\n    </View>\n  </View>\n);\n\nconst LightweightPlaceholder = ({ height, onLayout }) => (\n  <View\n    style={[styles.lightweightPlaceholder, { height }]}\n    onLayout={onLayout}\n  />\n);\n\n// Helper function to calculate distance from visible items\nconst getDistanceFromVisibleItems = (index, visibleIndices) => {\n  if (visibleIndices.length === 0) return Infinity;\n\n  return Math.min(\n    ...visibleIndices.map((visibleIndex) => Math.abs(index - visibleIndex))\n  );\n};\n\n// Helper function to estimate item height\nconst estimateHeightForItem = (item) => {\n  // Simple estimation based on content type\n  if (item.type === "header") return 150;\n  if (item.type === "image") return 200;\n  return 100; // Default height\n};\n'})}),"\n",(0,s.jsx)(n.p,{children:"Benefits of quantum rendering:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Progressive loading"}),": Renders high-quality content only where needed"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Perception optimization"}),": Focuses rendering resources on visible content"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Scroll performance"}),": Maintains smooth scrolling even with complex items"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Memory efficiency"}),": Uses lightweight placeholders for off-screen content"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Bandwidth optimization"}),": Can defer loading of images and heavy content"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"When to use quantum rendering:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Lists with complex, resource-intensive items"}),"\n",(0,s.jsx)(n.li,{children:"Content with high-resolution images or media"}),"\n",(0,s.jsx)(n.li,{children:"When scrolling performance is critical"}),"\n",(0,s.jsx)(n.li,{children:"Applications targeting devices with limited resources"}),"\n",(0,s.jsx)(n.li,{children:"Lists where perceived performance is more important than actual completeness"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"measuring-list-performance",children:"Measuring List Performance"}),"\n",(0,s.jsx)(n.p,{children:"To identify list performance issues:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Frame Rate Monitoring"}),": Use the Performance Monitor to track FPS during scrolling"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Render Timing"}),": Add timing logs in your ",(0,s.jsx)(n.code,{children:"renderItem"})," function"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Memory Usage"}),": Monitor memory consumption during scrolling"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Cell Reuse"}),": Log when cells are created vs. reused"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"best-practices-summary",children:"Best Practices Summary"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Configure accurate item sizes"})," with ",(0,s.jsx)(n.code,{children:"estimatedItemSize"})," and ",(0,s.jsx)(n.code,{children:"overrideItemLayout"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Optimize cell reuse"})," with ",(0,s.jsx)(n.code,{children:"getItemType"})," for different item templates"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Control cell lifecycle"})," with a custom ",(0,s.jsx)(n.code,{children:"CellRendererComponent"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Configure viewability"})," to optimize when items are processed"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Manage memory"})," with ",(0,s.jsx)(n.code,{children:"removeClippedSubviews"})," and ",(0,s.jsx)(n.code,{children:"windowSize"})," for large lists"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Eliminate layout calculations"})," with ",(0,s.jsx)(n.code,{children:"getItemLayout"})," for fixed-size items"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Use spatial hashmaps"})," for complex 2D layouts and precise visibility detection"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Implement memory mapping"})," for extremely large datasets"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Apply quantum rendering"})," for progressive loading based on visibility"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"advanced-techniques",children:"Advanced Techniques"}),"\n",(0,s.jsx)(n.h3,{id:"virtualized-loading-patterns",children:"Virtualized Loading Patterns"}),"\n",(0,s.jsx)(n.p,{children:"Implement progressive loading for complex lists:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:"const VirtualizedItem = ({ item, isFullyVisible }) => {\n  const [loadComplete, setLoadComplete] = useState(false);\n\n  // Only load full content when item is fully visible\n  useEffect(() => {\n    if (isFullyVisible && !loadComplete) {\n      // Load full content\n      setLoadComplete(true);\n    }\n  }, [isFullyVisible]);\n\n  return (\n    <View style={styles.container}>\n      <BasicContent item={item} />\n      {loadComplete ? <DetailedContent item={item} /> : <Placeholder />}\n    </View>\n  );\n};\n"})}),"\n",(0,s.jsx)(n.h3,{id:"data-windowing",children:"Data Windowing"}),"\n",(0,s.jsx)(n.p,{children:"For extremely large datasets, implement data windowing:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:"const useWindowedData = (fullData, windowSize = 200) => {\n  const [visibleRange, setVisibleRange] = useState({\n    start: 0,\n    end: windowSize,\n  });\n  const [windowedData, setWindowedData] = useState([]);\n\n  // Update windowed data when visible range changes\n  useEffect(() => {\n    setWindowedData(fullData.slice(visibleRange.start, visibleRange.end));\n  }, [fullData, visibleRange]);\n\n  const handleViewableItemsChanged = useCallback(\n    ({ viewableItems }) => {\n      if (viewableItems.length > 0) {\n        const firstVisible = viewableItems[0].index;\n        const lastVisible = viewableItems[viewableItems.length - 1].index;\n\n        // Calculate new window with buffer\n        const buffer = Math.floor(windowSize / 4);\n        const newStart = Math.max(0, firstVisible - buffer);\n        const newEnd = Math.min(fullData.length, lastVisible + buffer);\n\n        setVisibleRange({ start: newStart, end: newEnd });\n      }\n    },\n    [fullData.length, windowSize]\n  );\n\n  return { windowedData, handleViewableItemsChanged };\n};\n"})}),"\n",(0,s.jsx)(n.p,{children:"By implementing these optimization techniques, you can create high-performance lists that remain smooth even with thousands of items and complex content."})]})}function m(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>r,x:()=>a});var t=i(6540);const s={},l=t.createContext(s);function r(e){const n=t.useContext(l);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),t.createElement(l.Provider,{value:n},e.children)}}}]);