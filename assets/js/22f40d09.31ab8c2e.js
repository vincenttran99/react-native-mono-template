"use strict";(globalThis.webpackChunkdocs=globalThis.webpackChunkdocs||[]).push([[912],{1796:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"performance/flashlist-optimization","title":"FlashList and List Optimization","description":"Optimizing list components is crucial for React Native performance as they often represent the most complex and resource-intensive parts of mobile applications. This guide focuses on advanced techniques for optimizing FlashList and other list components.","source":"@site/docs/performance/flashlist-optimization.md","sourceDirName":"performance","slug":"/performance/flashlist-optimization","permalink":"/react-native-mono-template/docs/performance/flashlist-optimization","draft":false,"unlisted":false,"editUrl":"https://github.com/vincenttran99/react-native-mono-template/edit/main/docs/docs/performance/flashlist-optimization.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"docs","previous":{"title":"Component Structure Optimization","permalink":"/react-native-mono-template/docs/performance/component-structure-optimization"},"next":{"title":"Heavy Task Processing","permalink":"/react-native-mono-template/docs/performance/heavy-task-processing"}}');var s=i(4848),l=i(8453);const r={sidebar_position:3},a="FlashList and List Optimization",o={},d=[{value:"Why List Optimization Matters",id:"why-list-optimization-matters",level:2},{value:"Key Optimization Techniques",id:"key-optimization-techniques",level:2},{value:"1. Optimizing Cell Reuse with getItemType",id:"1-optimizing-cell-reuse-with-getitemtype",level:3},{value:"3. Controlling Cell Reuse with CellRendererComponent",id:"3-controlling-cell-reuse-with-cellrenderercomponent",level:3},{value:"4. Configuring Viewability for Optimal Performance",id:"4-configuring-viewability-for-optimal-performance",level:3},{value:"5. Using removeClippedSubviews and windowSize for Large Lists",id:"5-using-removeclippedsubviews-and-windowsize-for-large-lists",level:3},{value:"6. Using getItemLayout for Fixed-Size Items",id:"6-using-getitemlayout-for-fixed-size-items",level:3},{value:"7. Spatial Hashmap for Optimized Lists",id:"7-spatial-hashmap-for-optimized-lists",level:3},{value:"8. Quantum VirtualizedList (Progressive Loading)",id:"8-quantum-virtualizedlist-progressive-loading",level:3},{value:"Measuring List Performance",id:"measuring-list-performance",level:2},{value:"Best Practices Summary",id:"best-practices-summary",level:2},{value:"Advanced Techniques",id:"advanced-techniques",level:2},{value:"Virtualized Loading Patterns",id:"virtualized-loading-patterns",level:3},{value:"Data Windowing",id:"data-windowing",level:3}];function c(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,l.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"flashlist-and-list-optimization",children:"FlashList and List Optimization"})}),"\n",(0,s.jsx)(n.p,{children:"Optimizing list components is crucial for React Native performance as they often represent the most complex and resource-intensive parts of mobile applications. This guide focuses on advanced techniques for optimizing FlashList and other list components."}),"\n",(0,s.jsx)(n.h2,{id:"why-list-optimization-matters",children:"Why List Optimization Matters"}),"\n",(0,s.jsx)(n.p,{children:"Lists in React Native can cause performance issues due to:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Rendering many items"}),": Creating and laying out numerous components"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Frequent re-renders"}),": Updating items as data changes"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Memory consumption"}),": Keeping many items in memory"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Layout calculations"}),": Computing positions for dynamic content"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"FlashList addresses many of these concerns, but requires proper configuration to achieve optimal performance."}),"\n",(0,s.jsx)(n.h2,{id:"key-optimization-techniques",children:"Key Optimization Techniques"}),"\n",(0,s.jsx)(n.h3,{id:"1-optimizing-cell-reuse-with-getitemtype",children:"1. Optimizing Cell Reuse with getItemType"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"getItemType"})," property helps FlashList reuse cells more efficiently:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:"<FlashList\n  data={data}\n  renderItem={({ item }) => {\n    switch (item.type) {\n      case \"header\":\n        return <HeaderItem item={item} />;\n      case \"product\":\n        return <ProductItem item={item} />;\n      case \"ad\":\n        return <AdItem item={item} />;\n      default:\n        return <StandardItem item={item} />;\n    }\n  }}\n  getItemType={(item) => {\n    // Categorize items by type for better cell reuse\n    return item.type; // e.g., 'header', 'product', 'ad', 'standard'\n  }}\n/>\n"})}),"\n",(0,s.jsx)(n.p,{children:"Benefits:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Cells are reused within the same type pool"}),"\n",(0,s.jsx)(n.li,{children:"Reduces initialization overhead"}),"\n",(0,s.jsx)(n.li,{children:"Minimizes layout recalculations"}),"\n",(0,s.jsx)(n.li,{children:"Improves scrolling performance"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"3-controlling-cell-reuse-with-cellrenderercomponent",children:"3. Controlling Cell Reuse with CellRendererComponent"}),"\n",(0,s.jsxs)(n.p,{children:["For advanced control over cell reuse, implement a custom ",(0,s.jsx)(n.code,{children:"CellRendererComponent"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:'const MyCellRenderer = React.memo(\n  ({ item, index, children, style, onLayout }) => {\n    // Log when cells are being reused\n    console.log(`Cell for item ${item.id} (type: ${item.type}) being prepared`);\n\n    // Add custom logic for cell preparation or cleanup\n    useEffect(() => {\n      // Setup code when cell is reused\n      return () => {\n        // Cleanup code when cell is recycled\n      };\n    }, [item.id]);\n\n    return (\n      <View\n        style={[\n          style,\n          item.type === "important" ? styles.highlightedCell : null,\n        ]}\n        onLayout={onLayout}\n      >\n        {children}\n      </View>\n    );\n  }\n);\n\n<FlashList\n  data={data}\n  renderItem={renderItem}\n  CellRendererComponent={MyCellRenderer}\n/>;\n'})}),"\n",(0,s.jsx)(n.p,{children:"Use cases:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Adding cell-level animations or transitions"}),"\n",(0,s.jsx)(n.li,{children:"Implementing custom cell preparation logic"}),"\n",(0,s.jsx)(n.li,{children:"Monitoring cell reuse patterns"}),"\n",(0,s.jsx)(n.li,{children:"Adding cell-specific styling or behavior"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"4-configuring-viewability-for-optimal-performance",children:"4. Configuring Viewability for Optimal Performance"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"viewabilityConfig"})," and ",(0,s.jsx)(n.code,{children:"maintainVisibleContentPosition"})," properties help control when and how items are rendered:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:'<FlashList\n  data={data}\n  renderItem={renderItem}\n  viewabilityConfig={{\n    // Only consider items "viewable" when at least 50% visible\n    minimumViewTime: 300, // ms before considering item as "viewed"\n    viewAreaCoveragePercentThreshold: 50,\n    // Alternative: itemVisiblePercentThreshold: 50,\n    waitForInteraction: true, // Wait for user interaction before firing viewability callbacks\n  }}\n  maintainVisibleContentPosition={{\n    minIndexForVisible: 0,\n    autoscrollToTopThreshold: 10, // Auto-scroll to top when within 10px\n  }}\n  onViewableItemsChanged={onViewableItemsChanged}\n/>\n'})}),"\n",(0,s.jsx)(n.p,{children:"Benefits:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Control when viewability callbacks fire"}),"\n",(0,s.jsx)(n.li,{children:"Optimize content loading based on visibility"}),"\n",(0,s.jsx)(n.li,{children:"Maintain scroll position during data updates"}),"\n",(0,s.jsx)(n.li,{children:"Improve perceived performance"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"5-using-removeclippedsubviews-and-windowsize-for-large-lists",children:"5. Using removeClippedSubviews and windowSize for Large Lists"}),"\n",(0,s.jsx)(n.p,{children:"For very large lists, optimize memory usage with these properties:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:"<FlashList\n  data={largeDataset}\n  renderItem={renderItem}\n  removeClippedSubviews={true} // Detach off-screen views from the view hierarchy\n  windowSize={5} // Render items within 5 screen lengths (above and below)\n  maxToRenderPerBatch={10} // Limit items rendered in each batch\n  updateCellsBatchingPeriod={50} // ms between batch renders\n/>\n"})}),"\n",(0,s.jsx)(n.p,{children:"When to use:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"removeClippedSubviews"}),": For lists with hundreds or thousands of items"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"windowSize"}),": Adjust based on scroll speed and available memory"]}),"\n",(0,s.jsxs)(n.li,{children:["Smaller ",(0,s.jsx)(n.code,{children:"windowSize"})," values save memory but may cause blank areas during fast scrolling"]}),"\n",(0,s.jsx)(n.li,{children:"Larger values provide smoother scrolling but consume more memory"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"6-using-getitemlayout-for-fixed-size-items",children:"6. Using getItemLayout for Fixed-Size Items"}),"\n",(0,s.jsxs)(n.p,{children:["For lists with fixed-size items, ",(0,s.jsx)(n.code,{children:"getItemLayout"})," provides significant performance benefits:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:"<FlashList\n  data={data}\n  renderItem={renderItem}\n  getItemLayout={(data, index) => ({\n    length: 120, // Fixed height for each item\n    offset: 120 * index, // Position calculation\n    index,\n  })}\n/>\n"})}),"\n",(0,s.jsx)(n.p,{children:"Benefits:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Eliminates the need for measurement"}),"\n",(0,s.jsx)(n.li,{children:"Enables immediate scrolling to any position"}),"\n",(0,s.jsx)(n.li,{children:"Reduces layout calculation overhead"}),"\n",(0,s.jsx)(n.li,{children:"Improves initial render time"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"For variable-height items with predictable patterns:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:"const getItemLayout = (data, index) => {\n  // Example: Every 5th item is a header with different height\n  const isHeader = index % 5 === 0;\n  const itemHeight = isHeader ? 150 : 100;\n\n  // Calculate offset based on previous items\n  let offset = 0;\n  for (let i = 0; i < index; i++) {\n    offset += i % 5 === 0 ? 150 : 100;\n  }\n\n  return { length: itemHeight, offset, index };\n};\n"})}),"\n",(0,s.jsx)(n.h3,{id:"7-spatial-hashmap-for-optimized-lists",children:"7. Spatial Hashmap for Optimized Lists"}),"\n",(0,s.jsx)(n.p,{children:"Using spatial hashmaps allows you to render only items that are within the viewport, significantly improving performance for complex lists:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:'// Spatial hashmap implementation for optimized rendering\nclass SpatialViewport {\n  constructor(cellSize = 100) {\n    this.items = new Map();\n    this.cells = new Map();\n    this.cellSize = cellSize;\n  }\n\n  addItem(id, bounds) {\n    this.items.set(id, bounds);\n\n    const minCellX = Math.floor(bounds.x / this.cellSize);\n    const maxCellX = Math.floor((bounds.x + bounds.width) / this.cellSize);\n    const minCellY = Math.floor(bounds.y / this.cellSize);\n    const maxCellY = Math.floor((bounds.y + bounds.height) / this.cellSize);\n\n    for (let x = minCellX; x <= maxCellX; x++) {\n      for (let y = minCellY; y <= maxCellY; y++) {\n        const cellKey = `${x},${y}`;\n        if (!this.cells.has(cellKey)) {\n          this.cells.set(cellKey, new Set());\n        }\n        this.cells.get(cellKey).add(id);\n      }\n    }\n  }\n\n  getItemsInViewport(viewport) {\n    const minCellX = Math.floor(viewport.x / this.cellSize);\n    const maxCellX = Math.floor((viewport.x + viewport.width) / this.cellSize);\n    const minCellY = Math.floor(viewport.y / this.cellSize);\n    const maxCellY = Math.floor((viewport.y + viewport.height) / this.cellSize);\n\n    const itemsInView = new Set();\n\n    for (let x = minCellX; x <= maxCellX; x++) {\n      for (let y = minCellY; y <= maxCellY; y++) {\n        const cellKey = `${x},${y}`;\n        const itemsInCell = this.cells.get(cellKey);\n        if (itemsInCell) {\n          for (const id of itemsInCell) {\n            itemsInView.add(id);\n          }\n        }\n      }\n    }\n\n    return Array.from(itemsInView);\n  }\n}\n\n// Usage with FlashList\nconst SpatialOptimizedList = ({ data }) => {\n  const [visibleItems, setVisibleItems] = useState([]);\n  const spatialViewport = useRef(new SpatialViewport(100)).current;\n  const listRef = useRef(null);\n\n  // Update spatial data when items change\n  useEffect(() => {\n    data.forEach((item, index) => {\n      // Estimate item position based on index and size\n      const bounds = {\n        x: 0,\n        y: index * 100, // Estimated height\n        width: Dimensions.get("window").width,\n        height: 100,\n      };\n      spatialViewport.addItem(item.id, bounds);\n    });\n  }, [data]);\n\n  // Update visible items when scroll position changes\n  const handleScroll = (event) => {\n    const { y, height } = event.nativeEvent.contentOffset;\n    const viewport = {\n      x: 0,\n      y,\n      width: Dimensions.get("window").width,\n      height: height + Dimensions.get("window").height,\n    };\n\n    const visibleIds = spatialViewport.getItemsInViewport(viewport);\n    const newVisibleItems = visibleIds\n      .map((id) => data.find((item) => item.id === id))\n      .filter(Boolean);\n\n    setVisibleItems(newVisibleItems);\n  };\n\n  return (\n    <FlashList\n      ref={listRef}\n      data={visibleItems}\n      renderItem={({ item }) => <ListItem item={item} />}\n      onScroll={handleScroll}\n      scrollEventThrottle={16}\n    />\n  );\n};\n'})}),"\n",(0,s.jsx)(n.p,{children:"Benefits of spatial hashmaps:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Precise visibility detection"}),": Only render items that are actually visible"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Efficient for complex layouts"}),": Works well with grid layouts and non-linear arrangements"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Reduced rendering overhead"}),": Minimizes the number of components in the render tree"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Improved scrolling performance"}),": Less work during scroll events"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Memory efficiency"}),": Only keeps necessary items in memory"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"When to use spatial hashmaps:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Complex grid layouts with variable-sized items"}),"\n",(0,s.jsx)(n.li,{children:"Maps and spatial visualizations"}),"\n",(0,s.jsx)(n.li,{children:"Virtual canvases with many elements"}),"\n",(0,s.jsx)(n.li,{children:"Any list where items have 2D positions rather than just a linear arrangement"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"8-quantum-virtualizedlist-progressive-loading",children:"8. Quantum VirtualizedList (Progressive Loading)"}),"\n",(0,s.jsx)(n.p,{children:"This advanced technique renders list items with different quality levels based on their visibility:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:'const QuantumVirtualizedList = ({ data, renderItem }) => {\n  // Track data visibility with IntersectionObserver-like functionality\n  const [visibleIndices, setVisibleIndices] = useState(new Set([0, 1, 2]));\n  const listRef = useRef(null);\n\n  const quantumRenderItem = ({ item, index }) => {\n    // Render different quality based on visibility\n    if (visibleIndices.has(index)) {\n      // High-quality rendering for visible items\n      return renderItem({ item, index });\n    } else {\n      // Low-quality placeholder for invisible items\n      const distance = getDistanceFromVisibleItems(\n        index,\n        Array.from(visibleIndices)\n      );\n\n      if (distance < 5) {\n        // Medium quality for nearby items\n        return (\n          <MediumQualityPlaceholder\n            item={item}\n            onLayout={(e) => updateItemMetrics(index, e.nativeEvent.layout)}\n          />\n        );\n      } else {\n        // Ultra-lightweight placeholder for far items\n        return (\n          <LightweightPlaceholder\n            height={estimateHeightForItem(item)}\n            onLayout={(e) => updateItemMetrics(index, e.nativeEvent.layout)}\n          />\n        );\n      }\n    }\n  };\n\n  // Update visibility data based on scroll position\n  const handleViewableItemsChanged = ({ viewableItems }) => {\n    setVisibleIndices(new Set(viewableItems.map((v) => v.index)));\n  };\n\n  return (\n    <VirtualizedList\n      ref={listRef}\n      data={data}\n      renderItem={quantumRenderItem}\n      onViewableItemsChanged={handleViewableItemsChanged}\n      getItemCount={() => data.length}\n      getItem={(data, index) => data[index]}\n      viewabilityConfig={{\n        minimumViewTime: 100,\n        viewAreaCoveragePercentThreshold: 20,\n      }}\n    />\n  );\n};\n\n// Helper components for different quality levels\nconst MediumQualityPlaceholder = ({ item, onLayout }) => (\n  <View style={styles.mediumQualityItem} onLayout={onLayout}>\n    <View style={styles.avatarPlaceholder} />\n    <View style={styles.textPlaceholder}>\n      <View style={styles.titlePlaceholder} />\n      <View style={styles.subtitlePlaceholder} />\n    </View>\n  </View>\n);\n\nconst LightweightPlaceholder = ({ height, onLayout }) => (\n  <View\n    style={[styles.lightweightPlaceholder, { height }]}\n    onLayout={onLayout}\n  />\n);\n\n// Helper function to calculate distance from visible items\nconst getDistanceFromVisibleItems = (index, visibleIndices) => {\n  if (visibleIndices.length === 0) return Infinity;\n\n  return Math.min(\n    ...visibleIndices.map((visibleIndex) => Math.abs(index - visibleIndex))\n  );\n};\n\n// Helper function to estimate item height\nconst estimateHeightForItem = (item) => {\n  // Simple estimation based on content type\n  if (item.type === "header") return 150;\n  if (item.type === "image") return 200;\n  return 100; // Default height\n};\n'})}),"\n",(0,s.jsx)(n.p,{children:"Benefits of quantum rendering:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Progressive loading"}),": Renders high-quality content only where needed"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Perception optimization"}),": Focuses rendering resources on visible content"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Scroll performance"}),": Maintains smooth scrolling even with complex items"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Memory efficiency"}),": Uses lightweight placeholders for off-screen content"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Bandwidth optimization"}),": Can defer loading of images and heavy content"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"When to use quantum rendering:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Lists with complex, resource-intensive items"}),"\n",(0,s.jsx)(n.li,{children:"Content with high-resolution images or media"}),"\n",(0,s.jsx)(n.li,{children:"When scrolling performance is critical"}),"\n",(0,s.jsx)(n.li,{children:"Applications targeting devices with limited resources"}),"\n",(0,s.jsx)(n.li,{children:"Lists where perceived performance is more important than actual completeness"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"measuring-list-performance",children:"Measuring List Performance"}),"\n",(0,s.jsx)(n.p,{children:"To identify list performance issues:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Frame Rate Monitoring"}),": Use the Performance Monitor to track FPS during scrolling"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Render Timing"}),": Add timing logs in your ",(0,s.jsx)(n.code,{children:"renderItem"})," function"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Memory Usage"}),": Monitor memory consumption during scrolling"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Cell Reuse"}),": Log when cells are created vs. reused"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"best-practices-summary",children:"Best Practices Summary"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Optimize cell reuse"})," with ",(0,s.jsx)(n.code,{children:"getItemType"})," for different item templates"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Control cell lifecycle"})," with a custom ",(0,s.jsx)(n.code,{children:"CellRendererComponent"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Configure viewability"})," to optimize when items are processed"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Manage memory"})," with ",(0,s.jsx)(n.code,{children:"removeClippedSubviews"})," and ",(0,s.jsx)(n.code,{children:"windowSize"})," for large lists"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Eliminate layout calculations"})," with ",(0,s.jsx)(n.code,{children:"getItemLayout"})," for fixed-size items"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Use spatial hashmaps"})," for complex 2D layouts and precise visibility detection"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Implement memory mapping"})," for extremely large datasets"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Apply quantum rendering"})," for progressive loading based on visibility"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"advanced-techniques",children:"Advanced Techniques"}),"\n",(0,s.jsx)(n.h3,{id:"virtualized-loading-patterns",children:"Virtualized Loading Patterns"}),"\n",(0,s.jsx)(n.p,{children:"Implement progressive loading for complex lists:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:"const VirtualizedItem = ({ item, isFullyVisible }) => {\n  const [loadComplete, setLoadComplete] = useState(false);\n\n  // Only load full content when item is fully visible\n  useEffect(() => {\n    if (isFullyVisible && !loadComplete) {\n      // Load full content\n      setLoadComplete(true);\n    }\n  }, [isFullyVisible]);\n\n  return (\n    <View style={styles.container}>\n      <BasicContent item={item} />\n      {loadComplete ? <DetailedContent item={item} /> : <Placeholder />}\n    </View>\n  );\n};\n"})}),"\n",(0,s.jsx)(n.h3,{id:"data-windowing",children:"Data Windowing"}),"\n",(0,s.jsx)(n.p,{children:"For extremely large datasets, implement data windowing:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:"const useWindowedData = (fullData, windowSize = 200) => {\n  const [visibleRange, setVisibleRange] = useState({\n    start: 0,\n    end: windowSize,\n  });\n  const [windowedData, setWindowedData] = useState([]);\n\n  // Update windowed data when visible range changes\n  useEffect(() => {\n    setWindowedData(fullData.slice(visibleRange.start, visibleRange.end));\n  }, [fullData, visibleRange]);\n\n  const handleViewableItemsChanged = useCallback(\n    ({ viewableItems }) => {\n      if (viewableItems.length > 0) {\n        const firstVisible = viewableItems[0].index;\n        const lastVisible = viewableItems[viewableItems.length - 1].index;\n\n        // Calculate new window with buffer\n        const buffer = Math.floor(windowSize / 4);\n        const newStart = Math.max(0, firstVisible - buffer);\n        const newEnd = Math.min(fullData.length, lastVisible + buffer);\n\n        setVisibleRange({ start: newStart, end: newEnd });\n      }\n    },\n    [fullData.length, windowSize]\n  );\n\n  return { windowedData, handleViewableItemsChanged };\n};\n"})}),"\n",(0,s.jsx)(n.p,{children:"By implementing these optimization techniques, you can create high-performance lists that remain smooth even with thousands of items and complex content."})]})}function h(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>r,x:()=>a});var t=i(6540);const s={},l=t.createContext(s);function r(e){const n=t.useContext(l);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),t.createElement(l.Provider,{value:n},e.children)}}}]);