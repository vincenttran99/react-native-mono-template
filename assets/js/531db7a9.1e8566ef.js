"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[555],{8453:(n,e,t)=>{t.d(e,{R:()=>s,x:()=>o});var i=t(6540);const a={},r=i.createContext(a);function s(n){const e=i.useContext(r);return i.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function o(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(a):n.components||a:s(n.components),i.createElement(r.Provider,{value:e},n.children)}},9810:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>l,contentTitle:()=>o,default:()=>m,frontMatter:()=>s,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"performance/animation-optimization","title":"Animation Optimization","description":"Animations are a critical part of creating engaging mobile experiences, but they can also be a major source of performance issues in React Native applications. This guide focuses on techniques to optimize animations for smooth, 60fps performance.","source":"@site/docs/performance/animation-optimization.md","sourceDirName":"performance","slug":"/performance/animation-optimization","permalink":"/react-native-mono-template/docs/performance/animation-optimization","draft":false,"unlisted":false,"editUrl":"https://github.com/vincenttran99/react-native-mono-template/edit/main/docs/docs/performance/animation-optimization.md","tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"sidebar_position":5},"sidebar":"docs","previous":{"title":"Heavy Task Processing","permalink":"/react-native-mono-template/docs/performance/heavy-task-processing"},"next":{"title":"Image Optimization","permalink":"/react-native-mono-template/docs/performance/image-optimization"}}');var a=t(4848),r=t(8453);const s={sidebar_position:5},o="Animation Optimization",l={},c=[{value:"Understanding Animation Performance Challenges",id:"understanding-animation-performance-challenges",level:2},{value:"Key Optimization Techniques",id:"key-optimization-techniques",level:2},{value:"1. Using the Native Driver",id:"1-using-the-native-driver",level:3},{value:"2. Using React Native Reanimated 2",id:"2-using-react-native-reanimated-2",level:3},{value:"Gesture Handling",id:"gesture-handling",level:4},{value:"Layout Animations",id:"layout-animations",level:4},{value:"3. GreenSock-like Animation System",id:"3-greensock-like-animation-system",level:3},{value:"4. GPU-accelerated Filters and Effects",id:"4-gpu-accelerated-filters-and-effects",level:3},{value:"5. Gesture-driven Animation Optimization",id:"5-gesture-driven-animation-optimization",level:3},{value:"6. Hardware-accelerated Animation Paths",id:"6-hardware-accelerated-animation-paths",level:3},{value:"Measuring Animation Performance",id:"measuring-animation-performance",level:2},{value:"Best Practices Summary",id:"best-practices-summary",level:2},{value:"General Performance Optimization",id:"general-performance-optimization",level:3},{value:"Reanimated Optimization",id:"reanimated-optimization",level:3},{value:"GPU Acceleration",id:"gpu-acceleration",level:3},{value:"Gesture-driven Animation Optimization",id:"gesture-driven-animation-optimization",level:3},{value:"Testing and Monitoring",id:"testing-and-monitoring",level:3},{value:"Special Case Optimization",id:"special-case-optimization",level:3}];function d(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...n.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(e.header,{children:(0,a.jsx)(e.h1,{id:"animation-optimization",children:"Animation Optimization"})}),"\n",(0,a.jsx)(e.p,{children:"Animations are a critical part of creating engaging mobile experiences, but they can also be a major source of performance issues in React Native applications. This guide focuses on techniques to optimize animations for smooth, 60fps performance."}),"\n",(0,a.jsx)(e.h2,{id:"understanding-animation-performance-challenges",children:"Understanding Animation Performance Challenges"}),"\n",(0,a.jsx)(e.p,{children:"React Native animations can suffer from performance issues due to:"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"JavaScript Thread Blocking"}),": Traditional animations run on the JS thread, competing with other operations"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Bridge Overhead"}),": Communication between JS and native threads adds latency"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Layout Calculations"}),": Complex animations can trigger expensive layout recalculations"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Render Cycles"}),": Animations can cause cascading re-renders throughout your component tree"]}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"key-optimization-techniques",children:"Key Optimization Techniques"}),"\n",(0,a.jsx)(e.h3,{id:"1-using-the-native-driver",children:"1. Using the Native Driver"}),"\n",(0,a.jsxs)(e.p,{children:["The ",(0,a.jsx)(e.code,{children:"useNativeDriver"})," option moves animation execution to the native UI thread, bypassing JavaScript thread limitations:"]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-jsx",children:'import { Animated } from "react-native";\n\nconst AnimatedItem = ({ item }) => {\n  const opacity = useRef(new Animated.Value(0)).current;\n  const translateY = useRef(new Animated.Value(20)).current;\n\n  useEffect(() => {\n    // Run animations in parallel\n    Animated.parallel([\n      Animated.timing(opacity, {\n        toValue: 1,\n        duration: 300,\n        useNativeDriver: true, // Critical for performance\n      }),\n      Animated.timing(translateY, {\n        toValue: 0,\n        duration: 300,\n        useNativeDriver: true, // Critical for performance\n      }),\n    ]).start();\n  }, []);\n\n  return (\n    <Animated.View\n      style={[\n        styles.container,\n        {\n          opacity,\n          transform: [{ translateY }],\n        },\n      ]}\n    >\n      <Text>{item.title}</Text>\n    </Animated.View>\n  );\n};\n'})}),"\n",(0,a.jsx)(e.p,{children:"Native driver limitations:"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:["Only supports non-layout properties: ",(0,a.jsx)(e.code,{children:"opacity"}),", ",(0,a.jsx)(e.code,{children:"transform"})]}),"\n",(0,a.jsxs)(e.li,{children:["Cannot animate ",(0,a.jsx)(e.code,{children:"width"}),", ",(0,a.jsx)(e.code,{children:"height"}),", ",(0,a.jsx)(e.code,{children:"position"}),", ",(0,a.jsx)(e.code,{children:"margin"}),", etc."]}),"\n",(0,a.jsxs)(e.li,{children:["Cannot be used with ",(0,a.jsx)(e.code,{children:"Animated.event"})," for gesture-based animations that modify layout"]}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:"Best practices:"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:["Always use ",(0,a.jsx)(e.code,{children:"useNativeDriver: true"})," when animating supported properties"]}),"\n",(0,a.jsxs)(e.li,{children:["Prefer ",(0,a.jsx)(e.code,{children:"transform"})," animations over layout changes"]}),"\n",(0,a.jsxs)(e.li,{children:["Use ",(0,a.jsx)(e.code,{children:"translateX/Y"})," instead of ",(0,a.jsx)(e.code,{children:"left/top"})," position changes"]}),"\n",(0,a.jsxs)(e.li,{children:["Combine multiple animations with ",(0,a.jsx)(e.code,{children:"Animated.parallel"})," for efficiency"]}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"2-using-react-native-reanimated-2",children:"2. Using React Native Reanimated 2"}),"\n",(0,a.jsx)(e.p,{children:"Reanimated 2 provides a more powerful alternative to the standard Animated API, using worklets to run animations directly on the UI thread:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-jsx",children:'import Animated, {\n  useAnimatedStyle,\n  useSharedValue,\n  withTiming,\n  withSpring,\n  withDelay,\n} from "react-native-reanimated";\n\nconst WorkletOptimizedItem = ({ item }) => {\n  // Shared values are accessible from both JS and UI threads\n  const opacity = useSharedValue(0);\n  const translateY = useSharedValue(20);\n\n  // Styles defined with useAnimatedStyle run on the UI thread\n  const animatedStyles = useAnimatedStyle(() => {\n    return {\n      opacity: opacity.value,\n      transform: [{ translateY: translateY.value }],\n    };\n  });\n\n  useEffect(() => {\n    // Animations run directly on the UI thread\n    opacity.value = withTiming(1, { duration: 300 });\n    translateY.value = withSpring(0, { damping: 15 });\n  }, []);\n\n  return (\n    <Animated.View style={[styles.container, animatedStyles]}>\n      <Text>{item.title}</Text>\n    </Animated.View>\n  );\n};\n'})}),"\n",(0,a.jsx)(e.p,{children:"Advanced Reanimated 2 features:"}),"\n",(0,a.jsx)(e.h4,{id:"gesture-handling",children:"Gesture Handling"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-jsx",children:'import { PanGestureHandler } from "react-native-gesture-handler";\nimport Animated, {\n  useAnimatedGestureHandler,\n  useAnimatedStyle,\n  useSharedValue,\n  withSpring,\n} from "react-native-reanimated";\n\nconst DraggableCard = () => {\n  const translateX = useSharedValue(0);\n  const translateY = useSharedValue(0);\n\n  // Gesture handler runs on the UI thread\n  const gestureHandler = useAnimatedGestureHandler({\n    onStart: (_, ctx) => {\n      ctx.startX = translateX.value;\n      ctx.startY = translateY.value;\n    },\n    onActive: (event, ctx) => {\n      translateX.value = ctx.startX + event.translationX;\n      translateY.value = ctx.startY + event.translationY;\n    },\n    onEnd: () => {\n      translateX.value = withSpring(0);\n      translateY.value = withSpring(0);\n    },\n  });\n\n  const animatedStyle = useAnimatedStyle(() => {\n    return {\n      transform: [\n        { translateX: translateX.value },\n        { translateY: translateY.value },\n      ],\n    };\n  });\n\n  return (\n    <PanGestureHandler onGestureEvent={gestureHandler}>\n      <Animated.View style={[styles.card, animatedStyle]}>\n        <Text>Drag me!</Text>\n      </Animated.View>\n    </PanGestureHandler>\n  );\n};\n'})}),"\n",(0,a.jsx)(e.h4,{id:"layout-animations",children:"Layout Animations"}),"\n",(0,a.jsx)(e.p,{children:"Reanimated 2 can animate layout properties that the native driver cannot:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-jsx",children:'import Animated, {\n  useAnimatedStyle,\n  useSharedValue,\n  withTiming,\n  Layout,\n} from "react-native-reanimated";\n\nconst ExpandingCard = ({ expanded }) => {\n  const height = useSharedValue(60);\n\n  useEffect(() => {\n    height.value = withTiming(expanded ? 200 : 60, { duration: 300 });\n  }, [expanded]);\n\n  const animatedStyle = useAnimatedStyle(() => {\n    return {\n      height: height.value,\n    };\n  });\n\n  return (\n    <Animated.View\n      style={[styles.card, animatedStyle]}\n      layout={Layout.duration(300)} // Animate layout changes\n    >\n      <Text>Card Content</Text>\n      {expanded && (\n        <Animated.View\n          entering={FadeIn.duration(300)}\n          exiting={FadeOut.duration(300)}\n        >\n          <Text>Expanded content here...</Text>\n        </Animated.View>\n      )}\n    </Animated.View>\n  );\n};\n'})}),"\n",(0,a.jsx)(e.h3,{id:"3-greensock-like-animation-system",children:"3. GreenSock-like Animation System"}),"\n",(0,a.jsx)(e.p,{children:"Creating a high-performance animation system inspired by GreenSock can significantly improve animation fluidity and control:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-jsx",children:'// High-performance animation system based on requestAnimationFrame\nclass PerformanceAnimator {\n  constructor() {\n    this.animations = new Map();\n    this.running = false;\n    this.tick = this.tick.bind(this);\n  }\n\n  animate(id, options) {\n    const {\n      target,\n      duration = 300,\n      from,\n      to,\n      onUpdate,\n      onComplete,\n      easing,\n    } = options;\n\n    // Store animation configuration\n    this.animations.set(id, {\n      startTime: Date.now(),\n      endTime: Date.now() + duration,\n      from,\n      to,\n      target,\n      onUpdate,\n      onComplete,\n      easing: easing || this.easeOutQuad,\n    });\n\n    // Start animation loop if not already running\n    if (!this.running) {\n      this.running = true;\n      requestAnimationFrame(this.tick);\n    }\n\n    // Return control object\n    return {\n      cancel: () => this.animations.delete(id),\n      pause: () => {\n        const anim = this.animations.get(id);\n        if (anim) {\n          anim.paused = true;\n          anim.pausedTime = Date.now();\n        }\n      },\n      resume: () => {\n        const anim = this.animations.get(id);\n        if (anim && anim.paused) {\n          const pauseDuration = Date.now() - anim.pausedTime;\n          anim.startTime += pauseDuration;\n          anim.endTime += pauseDuration;\n          anim.paused = false;\n        }\n      },\n    };\n  }\n\n  // Easing functions\n  easeOutQuad(t) {\n    return t * (2 - t);\n  }\n\n  easeInOutQuad(t) {\n    return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;\n  }\n\n  easeOutElastic(t) {\n    const p = 0.3;\n    return (\n      Math.pow(2, -10 * t) * Math.sin(((t - p / 4) * (2 * Math.PI)) / p) + 1\n    );\n  }\n\n  // Animation loop\n  tick() {\n    const now = Date.now();\n\n    for (const [id, anim] of this.animations.entries()) {\n      // Skip paused animations\n      if (anim.paused) continue;\n\n      const {\n        startTime,\n        endTime,\n        from,\n        to,\n        target,\n        onUpdate,\n        onComplete,\n        easing,\n      } = anim;\n\n      if (now >= endTime) {\n        // Animation complete\n        onUpdate && onUpdate(to, 1, target);\n        onComplete && onComplete();\n        this.animations.delete(id);\n      } else {\n        // Animation in progress\n        const rawProgress = (now - startTime) / (endTime - startTime);\n        const progress = easing(rawProgress);\n\n        // Calculate current value based on animation type\n        let value;\n        if (typeof from === "object" && typeof to === "object") {\n          // Handle object animations (like multiple properties)\n          value = {};\n          for (const key in from) {\n            if (to.hasOwnProperty(key)) {\n              value[key] = from[key] + (to[key] - from[key]) * progress;\n            }\n          }\n        } else {\n          // Handle simple value animations\n          value = from + (to - from) * progress;\n        }\n\n        onUpdate && onUpdate(value, progress, target);\n      }\n    }\n\n    // Continue animation loop if animations remain\n    if (this.animations.size > 0) {\n      requestAnimationFrame(this.tick);\n    } else {\n      this.running = false;\n    }\n  }\n\n  // Timeline functionality\n  createTimeline() {\n    return new AnimationTimeline(this);\n  }\n}\n\n// Timeline implementation for sequence control\nclass AnimationTimeline {\n  constructor(animator) {\n    this.animator = animator;\n    this.sequence = [];\n    this.currentTime = 0;\n    this.controls = [];\n  }\n\n  add(options, position) {\n    const startTime = position === undefined ? this.currentTime : position;\n    const duration = options.duration || 300;\n\n    this.sequence.push({\n      ...options,\n      startTime,\n    });\n\n    this.currentTime = Math.max(this.currentTime, startTime + duration);\n    return this;\n  }\n\n  play() {\n    // Sort by start time\n    this.sequence.sort((a, b) => a.startTime - b.startTime);\n\n    // Start time reference\n    const timelineStart = Date.now();\n\n    // Process each animation\n    this.sequence.forEach((item) => {\n      setTimeout(() => {\n        const control = this.animator.animate(\n          `timeline-${Date.now()}-${Math.random()}`,\n          item\n        );\n        this.controls.push(control);\n      }, item.startTime);\n    });\n\n    return {\n      cancel: () => this.controls.forEach((control) => control.cancel()),\n      pause: () => this.controls.forEach((control) => control.pause()),\n      resume: () => this.controls.forEach((control) => control.resume()),\n    };\n  }\n}\n\n// Usage example\nconst animator = new PerformanceAnimator();\n\nconst AnimatedCard = ({ item }) => {\n  const ref = useRef();\n  const [expanded, setExpanded] = useState(false);\n\n  useEffect(() => {\n    if (!ref.current) return;\n\n    // Create animation timeline\n    const timeline = animator.createTimeline();\n\n    if (expanded) {\n      timeline\n        .add({\n          target: ref.current,\n          from: { opacity: 0.5, scale: 1 },\n          to: { opacity: 1, scale: 1.05 },\n          duration: 150,\n          easing: animator.easeOutQuad,\n          onUpdate: (value) => {\n            if (ref.current) {\n              ref.current.setNativeProps({\n                style: {\n                  opacity: value.opacity,\n                  transform: [{ scale: value.scale }],\n                },\n              });\n            }\n          },\n        })\n        .add({\n          target: ref.current,\n          from: { scale: 1.05 },\n          to: { scale: 1 },\n          duration: 150,\n          easing: animator.easeOutElastic,\n          onUpdate: (value) => {\n            if (ref.current) {\n              ref.current.setNativeProps({\n                style: {\n                  transform: [{ scale: value.scale }],\n                },\n              });\n            }\n          },\n        });\n    } else {\n      // Collapse animation\n      timeline.add({\n        target: ref.current,\n        from: { opacity: 1, scale: 1 },\n        to: { opacity: 0.5, scale: 0.95 },\n        duration: 200,\n        easing: animator.easeInOutQuad,\n        onUpdate: (value) => {\n          if (ref.current) {\n            ref.current.setNativeProps({\n              style: {\n                opacity: value.opacity,\n                transform: [{ scale: value.scale }],\n              },\n            });\n          }\n        },\n      });\n    }\n\n    const control = timeline.play();\n\n    return () => control.cancel();\n  }, [expanded]);\n\n  return (\n    <TouchableOpacity onPress={() => setExpanded(!expanded)}>\n      <View ref={ref} style={styles.card}>\n        <Text>{item.title}</Text>\n        {expanded && <Text>{item.description}</Text>}\n      </View>\n    </TouchableOpacity>\n  );\n};\n'})}),"\n",(0,a.jsx)(e.p,{children:"Key benefits of a custom animation system:"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Fine-grained control"}),": Custom easing functions and precise timing"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Performance optimization"}),": Direct manipulation of native properties"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Animation sequencing"}),": Timeline-based control similar to GreenSock"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Reduced overhead"}),": Minimal bridge communication"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Memory efficiency"}),": Proper cleanup and animation pooling"]}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"4-gpu-accelerated-filters-and-effects",children:"4. GPU-accelerated Filters and Effects"}),"\n",(0,a.jsx)(e.p,{children:"Leveraging GPU for visual effects dramatically improves performance:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-jsx",children:'import { BlurView } from "@react-native-community/blur";\nimport { SurfaceView } from "react-native-surface";\nimport FastImage from "react-native-fast-image";\nimport LinearGradient from "react-native-linear-gradient";\n\nconst GPUAcceleratedCard = ({ item }) => {\n  return (\n    <SurfaceView\n      style={styles.container}\n      blending="premultiplied" // GPU blending mode\n    >\n      {/* Hardware-accelerated image loading */}\n      <FastImage\n        source={{ uri: item.imageUrl }}\n        style={styles.backgroundImage}\n        resizeMode={FastImage.resizeMode.cover}\n      />\n\n      {/* GPU-accelerated blur effect */}\n      <BlurView\n        style={styles.blurOverlay}\n        blurType="light"\n        blurAmount={10}\n        reducedTransparencyFallbackColor="white"\n      >\n        {/* Hardware-accelerated gradient */}\n        <LinearGradient\n          colors={["rgba(0,0,0,0.7)", "rgba(0,0,0,0.3)", "transparent"]}\n          style={styles.gradient}\n        >\n          <Text style={styles.title}>{item.title}</Text>\n          <Text style={styles.subtitle}>{item.subtitle}</Text>\n        </LinearGradient>\n      </BlurView>\n\n      {/* Content container with hardware acceleration hints */}\n      <View\n        style={styles.contentContainer}\n        shouldRasterizeIOS={true}\n        renderToHardwareTextureAndroid={true}\n      >\n        <Text style={styles.description}>{item.description}</Text>\n      </View>\n    </SurfaceView>\n  );\n};\n\n// Optimized styles\nconst styles = StyleSheet.create({\n  container: {\n    width: "100%",\n    height: 300,\n    borderRadius: 12,\n    overflow: "hidden", // Important for performance\n    // Use transform instead of positioning where possible\n    transform: [{ translateZ: 0 }], // Hardware acceleration hint\n  },\n  backgroundImage: {\n    width: "100%",\n    height: "100%",\n    position: "absolute",\n  },\n  blurOverlay: {\n    position: "absolute",\n    top: 0,\n    left: 0,\n    right: 0,\n    height: 100,\n  },\n  gradient: {\n    width: "100%",\n    height: "100%",\n    padding: 16,\n    justifyContent: "flex-end",\n  },\n  contentContainer: {\n    padding: 16,\n    marginTop: 100,\n  },\n  title: {\n    color: "white",\n    fontSize: 24,\n    fontWeight: "bold",\n  },\n  subtitle: {\n    color: "white",\n    fontSize: 16,\n  },\n  description: {\n    fontSize: 14,\n    lineHeight: 20,\n  },\n});\n'})}),"\n",(0,a.jsx)(e.p,{children:"GPU acceleration techniques:"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"shouldRasterizeIOS"}),": Caches a flattened representation of the view hierarchy"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"renderToHardwareTextureAndroid"}),": Renders view to an off-screen buffer"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"FastImage"}),": Uses native image loading and caching"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"BlurView"}),": Offloads blur calculations to GPU"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"SurfaceView"}),": Provides direct access to hardware rendering"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"LinearGradient"}),": Hardware-accelerated gradient rendering"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsxs)(e.strong,{children:["transform: ",(0,a.jsx)(e.code,{children:"[{ translateZ: 0 }]"})]})," Forces hardware acceleration on some platforms"]}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:"Performance considerations:"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"Only use GPU acceleration for complex views that benefit from it"}),"\n",(0,a.jsx)(e.li,{children:"Excessive use can increase memory consumption"}),"\n",(0,a.jsx)(e.li,{children:"Monitor for memory leaks and performance regressions"}),"\n",(0,a.jsx)(e.li,{children:"Test on lower-end devices to ensure good performance across the board"}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"5-gesture-driven-animation-optimization",children:"5. Gesture-driven Animation Optimization"}),"\n",(0,a.jsx)(e.p,{children:"Optimizing animations triggered by user gestures requires special attention:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-jsx",children:'import {\n  PanGestureHandler,\n  TapGestureHandler,\n} from "react-native-gesture-handler";\nimport Animated, {\n  useAnimatedGestureHandler,\n  useAnimatedStyle,\n  useSharedValue,\n  withSpring,\n  withTiming,\n  runOnJS,\n  interpolate,\n  Extrapolate,\n} from "react-native-reanimated";\n\nconst OptimizedGestureCard = ({ item, onOpen }) => {\n  // Shared values for gesture tracking\n  const translateX = useSharedValue(0);\n  const translateY = useSharedValue(0);\n  const scale = useSharedValue(1);\n  const cardOpacity = useSharedValue(1);\n  const isActive = useSharedValue(false);\n\n  // Pre-compute gesture boundaries for performance\n  const SWIPE_THRESHOLD = 100;\n  const MAX_ROTATION = 15;\n\n  // Optimized pan gesture handler\n  const panGestureHandler = useAnimatedGestureHandler({\n    onStart: (_, ctx) => {\n      // Store initial position\n      ctx.startX = translateX.value;\n      ctx.startY = translateY.value;\n\n      // Immediate visual feedback\n      scale.value = withTiming(1.05, { duration: 150 });\n      isActive.value = true;\n    },\n    onActive: (event, ctx) => {\n      // Apply movement with constraints\n      translateX.value = ctx.startX + event.translationX;\n      translateY.value = ctx.startY + event.translationY;\n\n      // Calculate rotation based on horizontal movement (feels more natural)\n      const rotationValue = interpolate(\n        translateX.value,\n        [-200, 0, 200],\n        [MAX_ROTATION * -1, 0, MAX_ROTATION],\n        Extrapolate.CLAMP\n      );\n\n      // Apply rotation through transform style in useAnimatedStyle\n    },\n    onEnd: (event, ctx) => {\n      // Check if swipe threshold was exceeded\n      const swipedRight = event.translationX > SWIPE_THRESHOLD;\n      const swipedLeft = event.translationX < -SWIPE_THRESHOLD;\n      const swipedUp = event.translationY < -SWIPE_THRESHOLD;\n\n      if (swipedRight) {\n        // Swipe right animation\n        translateX.value = withTiming(500, { duration: 300 });\n        cardOpacity.value = withTiming(0, { duration: 300 });\n\n        // Notify JS thread after animation completes\n        runOnJS(onOpen)(item, "right");\n      } else if (swipedLeft) {\n        // Swipe left animation\n        translateX.value = withTiming(-500, { duration: 300 });\n        cardOpacity.value = withTiming(0, { duration: 300 });\n\n        runOnJS(onOpen)(item, "left");\n      } else if (swipedUp) {\n        // Swipe up animation\n        translateY.value = withTiming(-500, { duration: 300 });\n        cardOpacity.value = withTiming(0, { duration: 300 });\n\n        runOnJS(onOpen)(item, "up");\n      } else {\n        // Return to original position with spring physics\n        translateX.value = withSpring(0, {\n          damping: 15,\n          stiffness: 150,\n        });\n        translateY.value = withSpring(0, {\n          damping: 15,\n          stiffness: 150,\n        });\n        scale.value = withTiming(1, { duration: 150 });\n      }\n\n      isActive.value = false;\n    },\n  });\n\n  // Double tap handler with optimized animation\n  const doubleTapHandler = useAnimatedGestureHandler({\n    onActive: () => {\n      // Sequence of animations for double-tap\n      scale.value = withTiming(1.2, { duration: 100 }, () => {\n        scale.value = withSpring(1, {\n          damping: 15,\n          stiffness: 150,\n        });\n      });\n\n      // Notify JS thread\n      runOnJS(onOpen)(item, "doubleTap");\n    },\n  });\n\n  // Optimized animated styles\n  const animatedStyle = useAnimatedStyle(() => {\n    // Calculate rotation based on horizontal movement\n    const rotationValue = interpolate(\n      translateX.value,\n      [-200, 0, 200],\n      [MAX_ROTATION * -1, 0, MAX_ROTATION],\n      Extrapolate.CLAMP\n    );\n\n    // Shadow intensity based on elevation\n    const shadowOpacity = interpolate(\n      scale.value,\n      [1, 1.1],\n      [0.1, 0.3],\n      Extrapolate.CLAMP\n    );\n\n    return {\n      transform: [\n        { translateX: translateX.value },\n        { translateY: translateY.value },\n        { scale: scale.value },\n        { rotateZ: `${rotationValue}deg` },\n      ],\n      opacity: cardOpacity.value,\n      backgroundColor: isActive.value\n        ? "rgba(255,255,255,1)"\n        : "rgba(245,245,245,1)",\n      shadowOpacity: shadowOpacity,\n      shadowRadius: 10 * scale.value,\n      elevation: 5 * scale.value,\n    };\n  });\n\n  return (\n    <TapGestureHandler numberOfTaps={2} onGestureEvent={doubleTapHandler}>\n      <Animated.View>\n        <PanGestureHandler onGestureEvent={panGestureHandler}>\n          <Animated.View style={[styles.card, animatedStyle]}>\n            <FastImage\n              source={{ uri: item.imageUrl }}\n              style={styles.cardImage}\n              resizeMode={FastImage.resizeMode.cover}\n            />\n            <Text style={styles.cardTitle}>{item.title}</Text>\n          </Animated.View>\n        </PanGestureHandler>\n      </Animated.View>\n    </TapGestureHandler>\n  );\n};\n'})}),"\n",(0,a.jsx)(e.p,{children:"Key benefits of optimized gesture animations:"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Worklet-based execution"}),": All animation logic runs on the UI thread"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Immediate feedback"}),": Visual responses happen instantly without JS thread involvement"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Physics-based animations"}),": Natural-feeling interactions with spring physics"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Gesture prediction"}),": The system can predict gesture outcomes for smoother animations"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Reduced bridge traffic"}),": Minimal communication between JS and UI threads"]}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"6-hardware-accelerated-animation-paths",children:"6. Hardware-accelerated Animation Paths"}),"\n",(0,a.jsx)(e.p,{children:"For complex path animations, leveraging hardware acceleration can dramatically improve performance:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-jsx",children:'import Animated, {\n  useAnimatedProps,\n  useSharedValue,\n  withTiming,\n  withRepeat,\n  Easing,\n} from "react-native-reanimated";\nimport { Path, Svg } from "react-native-svg";\n\nconst AnimatedPath = Animated.createAnimatedComponent(Path);\n\nconst HardwareAcceleratedPathAnimation = () => {\n  // Animation progress value\n  const progress = useSharedValue(0);\n\n  // Start animation on mount\n  useEffect(() => {\n    progress.value = withRepeat(\n      withTiming(1, {\n        duration: 2000,\n        easing: Easing.bezier(0.25, 0.1, 0.25, 1),\n      }),\n      -1, // Infinite repetitions\n      true // Reverse on each iteration\n    );\n  }, []);\n\n  // Animated path properties\n  const animatedProps = useAnimatedProps(() => {\n    // Calculate path based on progress\n    const p = progress.value;\n\n    // Create a dynamic path that changes with animation progress\n    // This example creates a morphing curve\n    const startX = 50;\n    const startY = 100;\n    const endX = 300;\n    const endY = 100;\n    const controlX1 = 100 + 100 * Math.sin(p * Math.PI);\n    const controlY1 = 50 + 50 * Math.cos(p * Math.PI * 2);\n    const controlX2 = 250 - 100 * Math.sin(p * Math.PI);\n    const controlY2 = 150 - 50 * Math.cos(p * Math.PI * 2);\n\n    return {\n      d: `M ${startX} ${startY} C ${controlX1} ${controlY1}, ${controlX2} ${controlY2}, ${endX} ${endY}`,\n      stroke: `rgba(${Math.floor(255 * p)}, ${Math.floor(\n        100 + 155 * (1 - p)\n      )}, ${Math.floor(200 * (1 - p))}, 1)`,\n      strokeWidth: 2 + 3 * p,\n    };\n  });\n\n  return (\n    <View style={styles.container}>\n      <Svg width="100%" height="200">\n        <AnimatedPath animatedProps={animatedProps} fill="none" />\n      </Svg>\n    </View>\n  );\n};\n\n// Complex particle system with hardware acceleration\nconst ParticleSystem = ({ count = 50 }) => {\n  const particles = useMemo(() => {\n    return Array(count)\n      .fill(0)\n      .map((_, i) => ({\n        id: i,\n        x: useSharedValue(Math.random() * 300),\n        y: useSharedValue(Math.random() * 500),\n        scale: useSharedValue(0.5 + Math.random() * 1.5),\n        rotation: useSharedValue(0),\n        opacity: useSharedValue(0.3 + Math.random() * 0.7),\n        speed: 0.5 + Math.random() * 2,\n      }));\n  }, [count]);\n\n  // Animate all particles\n  useEffect(() => {\n    particles.forEach((particle) => {\n      // Create unique animation for each particle\n      particle.rotation.value = withRepeat(\n        withTiming(2 * Math.PI, {\n          duration: 5000 / particle.speed,\n          easing: Easing.linear,\n        }),\n        -1,\n        false\n      );\n\n      // Floating animation\n      const animatePosition = () => {\n        const targetX = Math.random() * 300;\n        const targetY = Math.random() * 500;\n        const duration = 3000 + Math.random() * 5000;\n\n        particle.x.value = withTiming(targetX, {\n          duration,\n          easing: Easing.bezier(0.25, 0.1, 0.25, 1),\n        });\n\n        particle.y.value = withTiming(\n          targetY,\n          {\n            duration,\n            easing: Easing.bezier(0.25, 0.1, 0.25, 1),\n          },\n          () => {\n            // When animation completes, start next animation\n            runOnJS(animatePosition)();\n          }\n        );\n      };\n\n      // Start animation loop\n      animatePosition();\n    });\n  }, [particles]);\n\n  return (\n    <View style={styles.particleContainer}>\n      {particles.map((particle) => (\n        <ParticleItem key={particle.id} particle={particle} />\n      ))}\n    </View>\n  );\n};\n\nconst ParticleItem = ({ particle }) => {\n  const animatedStyle = useAnimatedStyle(() => {\n    return {\n      position: "absolute",\n      left: particle.x.value,\n      top: particle.y.value,\n      opacity: particle.opacity.value,\n      transform: [\n        { scale: particle.scale.value },\n        { rotate: `${particle.rotation.value}rad` },\n      ],\n    };\n  });\n\n  return (\n    <Animated.View style={[styles.particle, animatedStyle]}>\n      <View style={styles.particleInner} />\n    </Animated.View>\n  );\n};\n'})}),"\n",(0,a.jsx)(e.p,{children:"Key benefits of hardware-accelerated path animations:"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"GPU-based rendering"}),": Path calculations are offloaded to the GPU"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Complex motion paths"}),": Support for bezier curves and complex trajectories"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Smooth transitions"}),": High frame rates even with many animated elements"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Dynamic path morphing"}),": Ability to smoothly transform between different paths"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Reduced CPU load"}),": Frees up CPU resources for other tasks"]}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"measuring-animation-performance",children:"Measuring Animation Performance"}),"\n",(0,a.jsx)(e.p,{children:"To identify animation performance issues:"}),"\n",(0,a.jsxs)(e.ol,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Frame Rate Monitoring"}),": Use the Performance Monitor to track FPS during animations"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Systrace"}),": Capture detailed thread activity on Android"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Chrome DevTools"}),": Profile JavaScript execution time during animations"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Interaction Timing"}),": Measure time between user input and visual response"]}),"\n"]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-jsx",children:'// Simple performance monitoring component\nconst PerformanceMonitor = ({ children }) => {\n  const [fps, setFps] = useState(0);\n  const frameCount = useRef(0);\n  const lastFrameTime = useRef(Date.now());\n  const frameId = useRef(null);\n\n  const measureFrameRate = () => {\n    frameCount.current += 1;\n    const now = Date.now();\n    const elapsed = now - lastFrameTime.current;\n\n    if (elapsed >= 1000) {\n      setFps(Math.round((frameCount.current * 1000) / elapsed));\n      frameCount.current = 0;\n      lastFrameTime.current = now;\n    }\n\n    frameId.current = requestAnimationFrame(measureFrameRate);\n  };\n\n  useEffect(() => {\n    frameId.current = requestAnimationFrame(measureFrameRate);\n    return () => cancelAnimationFrame(frameId.current);\n  }, []);\n\n  return (\n    <View style={styles.container}>\n      {children}\n      <View style={styles.fpsCounter}>\n        <Text\n          style={[\n            styles.fpsText,\n            { color: fps > 55 ? "green" : fps > 30 ? "orange" : "red" },\n          ]}\n        >\n          {fps} FPS\n        </Text>\n      </View>\n    </View>\n  );\n};\n'})}),"\n",(0,a.jsx)(e.h2,{id:"best-practices-summary",children:"Best Practices Summary"}),"\n",(0,a.jsx)(e.p,{children:"When optimizing animations in React Native applications, follow these best practices to achieve smooth, 60fps performance:"}),"\n",(0,a.jsx)(e.h3,{id:"general-performance-optimization",children:"General Performance Optimization"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Prioritize Native Driver"}),": Always use ",(0,a.jsx)(e.code,{children:"useNativeDriver: true"})," when possible to offload animations to the UI thread"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Avoid unnecessary re-renders"}),": Isolate animated components from their parents to prevent cascading re-renders"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Use transform properties over layout"}),": Prefer ",(0,a.jsx)(e.code,{children:"translateX/Y"})," over ",(0,a.jsx)(e.code,{children:"left/top"})," to leverage GPU acceleration"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Limit concurrent animations"}),": Reduce the number of simultaneous animations to avoid overloading CPU/GPU"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsxs)(e.strong,{children:["Use ",(0,a.jsx)(e.code,{children:"requestAnimationFrame"})," for custom animations"]}),": Synchronize with device render cycles to prevent frame drops"]}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"reanimated-optimization",children:"Reanimated Optimization"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Utilize worklets for complex logic"}),": Move animation logic to the UI thread to avoid blocking the JS thread"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Leverage shared values"}),": Use ",(0,a.jsx)(e.code,{children:"useSharedValue"})," to share values between JS and UI threads"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsxs)(e.strong,{children:["Minimize ",(0,a.jsx)(e.code,{children:"runOnJS"})," calls"]}),": Each call to ",(0,a.jsx)(e.code,{children:"runOnJS"})," incurs a performance cost"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsxs)(e.strong,{children:["Use ",(0,a.jsx)(e.code,{children:"useDerivedValue"})," for dependent values"]}),": Calculate derived values on the UI thread"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Take advantage of Layout Animation API"}),": Use ",(0,a.jsx)(e.code,{children:"Layout.duration()"})," for complex layout animations"]}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"gpu-acceleration",children:"GPU Acceleration"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsxs)(e.strong,{children:["Selectively use ",(0,a.jsx)(e.code,{children:"shouldRasterizeIOS"})," and ",(0,a.jsx)(e.code,{children:"renderToHardwareTextureAndroid"})]}),": Apply only to complex views"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Avoid overusing blur and shadow effects"}),": These effects are GPU-intensive"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsxs)(e.strong,{children:["Use ",(0,a.jsx)(e.code,{children:"overflow: 'hidden'"})," for containers"]}),": Minimize the area that needs redrawing"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Optimize images"}),": Use ",(0,a.jsx)(e.code,{children:"FastImage"})," and ensure appropriate image dimensions"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsxs)(e.strong,{children:["Apply ",(0,a.jsx)(e.code,{children:"transform: [{ translateZ: 0 }]"})]}),": Hint to the renderer to use hardware acceleration"]}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"gesture-driven-animation-optimization",children:"Gesture-driven Animation Optimization"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsxs)(e.strong,{children:["Use ",(0,a.jsx)(e.code,{children:"PanResponder"})," or ",(0,a.jsx)(e.code,{children:"react-native-gesture-handler"})]}),": Leverage native gesture APIs"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Pre-compute thresholds and boundaries"}),": Define values like ",(0,a.jsx)(e.code,{children:"SWIPE_THRESHOLD"})," in advance"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Provide immediate visual feedback"}),": Respond as soon as the user begins interaction"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Use spring physics for natural feel"}),": Animations with ",(0,a.jsx)(e.code,{children:"withSpring"})," feel more natural"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsxs)(e.strong,{children:["Optimize ",(0,a.jsx)(e.code,{children:"onGestureEvent"})," handlers"]}),": Ensure gesture handlers are lightweight and efficient"]}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"testing-and-monitoring",children:"Testing and Monitoring"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Test on real devices"}),": Don't rely solely on emulators or high-end devices"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Use Flipper to analyze performance"}),": Monitor frame drops and execution time"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Test on low-end devices"}),": Ensure smooth experience across a range of devices"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Monitor memory usage"}),": Watch for memory leaks from improperly cleaned up animations"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Measure FPS"}),": Use tools like ",(0,a.jsx)(e.code,{children:"react-native-fps-monitor"})," to track frame rates"]}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"special-case-optimization",children:"Special Case Optimization"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Long lists"}),": Use ",(0,a.jsx)(e.code,{children:"VirtualizedList"})," or ",(0,a.jsx)(e.code,{children:"FlashList"})," with optimized ",(0,a.jsx)(e.code,{children:"CellRendererComponent"})]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Screen transitions"}),": Use ",(0,a.jsx)(e.code,{children:"react-navigation"})," with optimized animations"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Charts and graphs"}),": Consider optimized SVG or Canvas-based libraries"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Special effects"}),": Use native libraries like ",(0,a.jsx)(e.code,{children:"lottie-react-native"})," for complex animations"]}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:"By following these principles, you can create smooth, efficient, and resource-friendly animations in your React Native applications."})]})}function m(n={}){const{wrapper:e}={...(0,r.R)(),...n.components};return e?(0,a.jsx)(e,{...n,children:(0,a.jsx)(d,{...n})}):d(n)}}}]);