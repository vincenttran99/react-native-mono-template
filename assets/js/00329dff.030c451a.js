"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[5223],{6254:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>c,default:()=>m,frontMatter:()=>o,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"performance/component-structure-optimization","title":"Component Structure Optimization","description":"Optimizing component structure is a critical aspect of React Native performance. A well-structured component hierarchy can significantly reduce rendering time, memory usage, and improve overall app responsiveness.","source":"@site/docs/performance/component-structure-optimization.md","sourceDirName":"performance","slug":"/performance/component-structure-optimization","permalink":"/react-native-mono-template/docs/performance/component-structure-optimization","draft":false,"unlisted":false,"editUrl":"https://github.com/vincenttran99/react-native-mono-template/edit/main/docs/docs/performance/component-structure-optimization.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"docs","previous":{"title":"Re-rendering Optimization","permalink":"/react-native-mono-template/docs/performance/re-rendering-optimization"},"next":{"title":"FlashList and List Optimization","permalink":"/react-native-mono-template/docs/performance/flashlist-optimization"}}');var r=t(4848),s=t(8453);const o={sidebar_position:2},c="Component Structure Optimization",a={},l=[{value:"Why Component Structure Matters",id:"why-component-structure-matters",level:2},{value:"Key Optimization Techniques",id:"key-optimization-techniques",level:2},{value:"1. Designing Optimized Component Hierarchies",id:"1-designing-optimized-component-hierarchies",level:3},{value:"2. Optimizing Layout Calculations",id:"2-optimizing-layout-calculations",level:3},{value:"3. Minimizing Component Tree Depth and Node Count",id:"3-minimizing-component-tree-depth-and-node-count",level:3},{value:"4. Using Bitmap Caching for Static Components",id:"4-using-bitmap-caching-for-static-components",level:3},{value:"5. Using Fragments to Avoid Unnecessary View Containers",id:"5-using-fragments-to-avoid-unnecessary-view-containers",level:3},{value:"6. Fabric Renderer Optimizations (React Native New Architecture)",id:"6-fabric-renderer-optimizations-react-native-new-architecture",level:3},{value:"7. Runtime Bytecode Generation for Complex Components",id:"7-runtime-bytecode-generation-for-complex-components",level:3},{value:"8. Time Slicing and Concurrent Mode",id:"8-time-slicing-and-concurrent-mode",level:3},{value:"Measuring Component Structure Performance",id:"measuring-component-structure-performance",level:2},{value:"Best Practices Summary",id:"best-practices-summary",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"component-structure-optimization",children:"Component Structure Optimization"})}),"\n",(0,r.jsx)(n.p,{children:"Optimizing component structure is a critical aspect of React Native performance. A well-structured component hierarchy can significantly reduce rendering time, memory usage, and improve overall app responsiveness."}),"\n",(0,r.jsx)(n.h2,{id:"why-component-structure-matters",children:"Why Component Structure Matters"}),"\n",(0,r.jsx)(n.p,{children:"The structure of your components directly impacts:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Render performance"}),": Fewer and simpler components render faster"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Memory usage"}),": Optimized structures consume less memory"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Layout calculation time"}),": Simpler layouts calculate faster"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Re-render efficiency"}),": Well-structured components minimize unnecessary re-renders"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"key-optimization-techniques",children:"Key Optimization Techniques"}),"\n",(0,r.jsx)(n.h3,{id:"1-designing-optimized-component-hierarchies",children:"1. Designing Optimized Component Hierarchies"}),"\n",(0,r.jsx)(n.p,{children:"Breaking down complex components into logical, reusable parts improves both performance and maintainability:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-jsx",children:"// Optimized component structure\nconst ListItem = React.memo(\n  ({ item }) => {\n    // Split into sub-components to prevent full item re-renders\n    return (\n      <View style={styles.container}>\n        <HeaderSection title={item.title} timestamp={item.timestamp} />\n        <ContentSection content={item.content} />\n        <MediaSection media={item.media} />\n        <FooterSection actions={item.actions} />\n      </View>\n    );\n  },\n  (prevProps, nextProps) => {\n    // Custom comparison to prevent unnecessary re-renders\n    return (\n      prevProps.item.id === nextProps.item.id &&\n      prevProps.item.version === nextProps.item.version\n    );\n  }\n);\n\n// Each section can have its own memoization and optimization\nconst HeaderSection = React.memo(({ title, timestamp }) => (\n  <View style={styles.header}>\n    <Text style={styles.title}>{title}</Text>\n    <Text style={styles.timestamp}>{formatTimestamp(timestamp)}</Text>\n  </View>\n));\n"})}),"\n",(0,r.jsx)(n.p,{children:"This approach:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Isolates re-renders to only the sections that change"}),"\n",(0,r.jsx)(n.li,{children:"Allows for section-specific optimizations"}),"\n",(0,r.jsx)(n.li,{children:"Improves code maintainability and testability"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"2-optimizing-layout-calculations",children:"2. Optimizing Layout Calculations"}),"\n",(0,r.jsx)(n.p,{children:"Layout calculations can be expensive, especially for complex or deeply nested components:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-jsx",children:"const OptimizedLayout = ({ children }) => (\n  <View\n    style={styles.container}\n    removeClippedSubviews={true}\n    shouldRasterizeIOS={true} // iOS: Convert view to bitmap\n    renderToHardwareTextureAndroid={true} // Android: Use GPU rendering\n  >\n    {children}\n  </View>\n);\n"})}),"\n",(0,r.jsx)(n.p,{children:"Key techniques:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"shouldRasterizeIOS"}),": Converts the view and its subviews to a bitmap on iOS, reducing layout calculations for static content"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"renderToHardwareTextureAndroid"}),": Moves the view to its own layer backed by hardware on Android"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"removeClippedSubviews"}),": Detaches views that are outside the viewport from the native view hierarchy"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"3-minimizing-component-tree-depth-and-node-count",children:"3. Minimizing Component Tree Depth and Node Count"}),"\n",(0,r.jsx)(n.p,{children:"Each node in your component tree adds overhead to layout calculations and rendering:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-jsx",children:"// Inefficient structure with unnecessary nesting\nconst IneffectiveStructure = () => (\n  <View style={styles.container}>\n    <View style={styles.wrapper}>\n      <View style={styles.innerWrapper}>\n        <Text style={styles.text}>{title}</Text>\n      </View>\n    </View>\n    <View style={styles.contentWrapper}>\n      <Text style={styles.description}>{description}</Text>\n    </View>\n  </View>\n);\n\n// Optimized structure with fewer nodes\nconst OptimizedStructure = () => (\n  <View style={styles.container}>\n    <Text style={styles.title}>{title}</Text>\n    <Text style={styles.description}>{description}</Text>\n  </View>\n);\n"})}),"\n",(0,r.jsx)(n.p,{children:"Best practices:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Flatten component hierarchies when possible"}),"\n",(0,r.jsx)(n.li,{children:"Apply styles directly to components instead of wrapping them in additional Views"}),"\n",(0,r.jsx)(n.li,{children:"Use compound styles instead of nested Views for layout purposes"}),"\n",(0,r.jsx)(n.li,{children:"Avoid deeply nested conditional rendering"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"4-using-bitmap-caching-for-static-components",children:"4. Using Bitmap Caching for Static Components"}),"\n",(0,r.jsx)(n.p,{children:"For components that rarely change, bitmap caching can significantly improve performance:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-jsx",children:"const StaticComponent = ({ title, imageUrl }) => (\n  <View\n    style={styles.container}\n    shouldRasterizeIOS={true} // iOS optimization\n    renderToHardwareTextureAndroid={true} // Android optimization\n  >\n    <Text style={styles.title}>{title}</Text>\n    <Image source={{ uri: imageUrl }} style={styles.image} />\n  </View>\n);\n"})}),"\n",(0,r.jsx)(n.p,{children:"When to use bitmap caching:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Static headers and footers"}),"\n",(0,r.jsx)(n.li,{children:"Complex UI elements that don't change frequently"}),"\n",(0,r.jsx)(n.li,{children:"Components with complex shadows, gradients, or effects"}),"\n",(0,r.jsx)(n.li,{children:"List items that don't animate or change appearance"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Note"}),": Only use bitmap caching for components that don't change frequently, as updating cached bitmaps is expensive."]}),"\n",(0,r.jsx)(n.h3,{id:"5-using-fragments-to-avoid-unnecessary-view-containers",children:"5. Using Fragments to Avoid Unnecessary View Containers"}),"\n",(0,r.jsx)(n.p,{children:"React Fragments allow you to group elements without adding extra nodes to the DOM:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-jsx",children:"// Inefficient approach with unnecessary View\nconst Wrapper = () => (\n  <View>\n    <Text>Item 1</Text>\n    <Text>Item 2</Text>\n  </View>\n);\n\n// Optimized approach using Fragment\nconst Better = () => (\n  <>\n    <Text>Item 1</Text>\n    <Text>Item 2</Text>\n  </>\n);\n\n// Alternative array syntax for fragments with keys\nconst ListItems = ({ items }) => (\n  <>\n    {items.map((item) => (\n      <React.Fragment key={item.id}>\n        <ItemHeader data={item.header} />\n        <ItemContent data={item.content} />\n      </React.Fragment>\n    ))}\n  </>\n);\n"})}),"\n",(0,r.jsx)(n.p,{children:"Benefits of using Fragments:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Reduces the number of view nodes in the component tree"}),"\n",(0,r.jsx)(n.li,{children:"Decreases memory usage"}),"\n",(0,r.jsx)(n.li,{children:"Improves layout calculation performance"}),"\n",(0,r.jsx)(n.li,{children:"Maintains logical component grouping without performance penalty"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"6-fabric-renderer-optimizations-react-native-new-architecture",children:"6. Fabric Renderer Optimizations (React Native New Architecture)"}),"\n",(0,r.jsx)(n.p,{children:"The Fabric Renderer in React Native's New Architecture provides significant performance improvements through a completely rewritten rendering system:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-jsx",children:'// Optimizations for React Native\'s Fabric Renderer\nimport { unstable_createElement } from "react-native";\n\nconst FabricOptimizedComponent = ({ item }) => {\n  // Apply special props when using Fabric Renderer\n  return unstable_createElement(\n    "View",\n    {\n      style: styles.container,\n      // Fabric-specific optimizations\n      nativeID: `item-${item.id}`,\n      collapsable: false, // Disable view flattening when needed\n    },\n    [\n      <Text key="title">{item.title}</Text>,\n      <Image\n        key="image"\n        source={{ uri: item.imageUrl }}\n        style={styles.image}\n      />,\n    ]\n  );\n};\n'})}),"\n",(0,r.jsx)(n.p,{children:"Key Fabric Renderer optimizations:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Synchronous Layout"}),": Fabric enables synchronous communication between JavaScript and native, reducing layout latency"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Persistent Render Tree"}),": Maintains a persistent tree across renders for better diffing"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Direct JSI Access"}),": Bypasses the bridge for faster communication with native modules"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Concurrent Rendering"}),": Supports React's Concurrent Mode for more responsive UIs"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Improved Memory Management"}),": Better memory usage through more efficient C++ implementation"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"When to use Fabric-specific optimizations:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Performance-critical screens with complex layouts"}),"\n",(0,r.jsx)(n.li,{children:"Components that need precise layout measurements"}),"\n",(0,r.jsx)(n.li,{children:"UIs with frequent animations or transitions"}),"\n",(0,r.jsx)(n.li,{children:"Components that need to avoid the bridge bottleneck"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"7-runtime-bytecode-generation-for-complex-components",children:"7. Runtime Bytecode Generation for Complex Components"}),"\n",(0,r.jsx)(n.p,{children:"For extremely performance-critical components, runtime bytecode generation can provide significant optimizations:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-jsx",children:"// Advanced technique, for illustration purposes only\nfunction createHighPerformanceComponent(renderFn) {\n  // Create optimized render function\n  const optimizedRenderFn = new Function(\n    \"props\",\n    \"React\",\n    \"styles\",\n    `\n    // Optimize rendering paths\n    const { item } = props;\n    if (!item) return React.createElement('View', {});\n\n    // Fast path for common case\n    if (item.type === 'simple') {\n      return React.createElement(\n        'View',\n        { style: styles.container },\n        React.createElement('Text', { style: styles.text }, item.title)\n      );\n    }\n\n    // Regular path for other cases\n    return (${renderFn.toString()})(props);\n    `\n  );\n\n  // Component using optimized render function\n  return React.memo((props) => {\n    return optimizedRenderFn(props, React, styles);\n  });\n}\n\n// Usage\nconst UltraFastComponent = createHighPerformanceComponent((props) => {\n  const { item } = props;\n  return (\n    <View style={styles.container}>\n      <Text style={styles.text}>{item.title}</Text>\n      {item.subtitle && <Text style={styles.subtext}>{item.subtitle}</Text>}\n    </View>\n  );\n});\n"})}),"\n",(0,r.jsx)(n.p,{children:"Benefits of runtime bytecode generation:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Optimized Execution Paths"}),": Creates specialized code paths for common scenarios"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"JIT-Friendly Code"}),": Generates code that's optimized for JavaScript engines"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Reduced Overhead"}),": Eliminates React's reconciliation for known patterns"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Custom Optimizations"}),": Allows for component-specific performance tuning"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"When to consider this approach:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Ultra-performance-critical components rendered thousands of times"}),"\n",(0,r.jsx)(n.li,{children:"Components with predictable rendering patterns"}),"\n",(0,r.jsx)(n.li,{children:"When profiling shows significant reconciliation overhead"}),"\n",(0,r.jsx)(n.li,{children:"As a last resort after trying standard optimization techniques"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Note"}),": This is an advanced technique that should be used sparingly and with caution, as it bypasses React's standard rendering mechanisms."]}),"\n",(0,r.jsx)(n.h3,{id:"8-time-slicing-and-concurrent-mode",children:"8. Time Slicing and Concurrent Mode"}),"\n",(0,r.jsx)(n.p,{children:"Time slicing allows you to break up rendering work into smaller chunks to avoid blocking the main thread:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-jsx",children:'import { unstable_scheduleCallback, unstable_NormalPriority } from "scheduler";\n\nconst TimeSlicedRendering = ({ items }) => {\n  const [renderedItems, setRenderedItems] = useState([]);\n\n  useEffect(() => {\n    let canceled = false;\n\n    const renderInChunks = (allItems) => {\n      const CHUNK_SIZE = 10;\n      let currentIndex = 0;\n\n      const processNextChunk = () => {\n        if (canceled) return;\n\n        const chunk = allItems.slice(currentIndex, currentIndex + CHUNK_SIZE);\n        currentIndex += CHUNK_SIZE;\n\n        setRenderedItems((prev) => [...prev, ...chunk]);\n\n        if (currentIndex < allItems.length) {\n          // Schedule next chunk with normal priority\n          unstable_scheduleCallback(unstable_NormalPriority, processNextChunk);\n        }\n      };\n\n      // Start processing\n      processNextChunk();\n    };\n\n    setRenderedItems([]);\n    renderInChunks(items);\n\n    return () => {\n      canceled = true;\n    };\n  }, [items]);\n\n  return (\n    <View>\n      {renderedItems.map((item) => (\n        <ItemComponent key={item.id} item={item} />\n      ))}\n    </View>\n  );\n};\n'})}),"\n",(0,r.jsx)(n.p,{children:"Benefits of time slicing:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Improved Responsiveness"}),": Prevents UI freezing during heavy rendering"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Prioritized Updates"}),": Allows critical updates to take precedence"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Better User Experience"}),": Maintains smooth animations and interactions"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Progressive Rendering"}),": Shows content incrementally rather than all at once"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"When to use time slicing:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Rendering large lists or complex data visualizations"}),"\n",(0,r.jsx)(n.li,{children:"Initial app loading with many components"}),"\n",(0,r.jsx)(n.li,{children:"Processing and rendering large datasets"}),"\n",(0,r.jsx)(n.li,{children:"Any scenario where rendering might block the main thread for >16ms"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Note"}),": While React 18 provides built-in concurrent features, this example shows how to implement similar functionality in earlier versions."]}),"\n",(0,r.jsx)(n.h2,{id:"measuring-component-structure-performance",children:"Measuring Component Structure Performance"}),"\n",(0,r.jsx)(n.p,{children:"To identify structural performance issues:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"React DevTools Profiler"}),": Analyze component render times and counts"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Flipper Layout Inspector"}),": Examine the native view hierarchy"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Performance Monitor"}),": Track FPS drops during rendering and scrolling"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Systrace"}),": Capture detailed performance traces on Android"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"best-practices-summary",children:"Best Practices Summary"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Break down complex components"})," into logical, memoized sub-components"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Optimize layout calculations"})," with shouldRasterizeIOS and renderToHardwareTextureAndroid"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Minimize component tree depth"})," by flattening hierarchies and removing unnecessary containers"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Use bitmap caching"})," for static components that rarely change"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Replace unnecessary Views with Fragments"})," to reduce node count"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Leverage Fabric Renderer optimizations"})," for performance-critical components"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Consider runtime bytecode generation"})," for extremely performance-sensitive scenarios"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Implement time slicing"})," for heavy rendering workloads"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Measure and profile"})," to identify structural bottlenecks"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"By implementing these techniques, you can create a more efficient component structure that renders faster, uses less memory, and provides a smoother user experience."})]})}function m(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>c});var i=t(6540);const r={},s=i.createContext(r);function o(e){const n=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);